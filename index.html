
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foresight & AI Policy Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
            line-height: 1.6;
        }

        /* Navigation */
        .navbar {
            background-color: #1a237e;
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .navbar-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            transition: opacity 0.3s;
        }

        .nav-links a:hover {
            opacity: 0.8;
        }

        /* Main Layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }

        /* Sidebar */
        .sidebar {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            height: fit-content;
            position: sticky;
            top: 2rem;
        }

        .progress-indicator {
            margin-bottom: 2rem;
        }

        .progress-bar {
            background: #e0e0e0;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            background: #4caf50;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .phase-list {
            list-style: none;
        }

        .phase-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .phase-item:hover {
            background: #f5f7fa;
        }

        .phase-item.active {
            background: #e3f2fd;
            color: #1976d2;
            font-weight: 500;
        }

        .phase-item.completed {
            color: #4caf50;
        }

        .phase-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .phase-item.completed .phase-icon {
            background: #4caf50;
            color: white;
        }

        .phase-item.active .phase-icon {
            background: #1976d2;
            color: white;
        }

        /* Main Content Area */
        .main-content {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .content-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .content-header h1 {
            color: #1a237e;
            margin-bottom: 0.5rem;
        }

        .content-header p {
            color: #666;
        }

        /* Form Elements */
        .form-section {
            margin-bottom: 2rem;
        }

        .form-section h3 {
            margin-bottom: 1rem;
            color: #333;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }

        input[type="text"],
        input[type="file"],
        textarea,
        select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #1976d2;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #1976d2;
            background: #f5f7fa;
        }

        .upload-icon {
            font-size: 3rem;
            color: #999;
            margin-bottom: 1rem;
        }

        /* AI Generation Card */
        .ai-card {
            background: #f5f7fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .ai-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .ai-badge {
            background: #673ab7;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #1976d2;
            color: white;
        }

        .btn-primary:hover {
            background: #1565c0;
        }

        .btn-secondary {
            background: #f5f7fa;
            color: #333;
            border: 1px solid #ddd;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .btn-ai {
            background: #673ab7;
            color: white;
        }

        .btn-ai:hover {
            background: #5e35b1;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            justify-content: space-between;
        }

        /* Generated Content */
        .generated-content {
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1rem;
            margin-top: 1rem;
            position: relative;
        }

        .edit-toggle {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: white;
            border: 1px solid #ddd;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #f5f7fa;
        }

        .tab.active {
            color: #1976d2;
            border-bottom-color: #1976d2;
        }

        /* Cards Grid */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s;
            cursor: pointer;
        }

        .card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .card h4 {
            color: #1a237e;
            margin-bottom: 0.75rem;
        }

        .card p {
            color: #666;
            font-size: 0.9rem;
        }

        /* Signal Cards */
        .signal-card {
            background: #f8f9fa;
            border-left: 4px solid #1976d2;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
        }

        .signal-card.weak {
            border-left-color: #ff9800;
        }

        .signal-card.strong {
            border-left-color: #4caf50;
        }

        /* Matrix Builder */
        .matrix-container {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 2rem;
            margin-top: 1.5rem;
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .matrix-cell {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1rem;
            text-align: center;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .matrix-cell:hover {
            background: #f5f7fa;
        }

        .matrix-header {
            background: #1a237e;
            color: white;
            font-weight: bold;
        }

        /* Hide/Show Content */
        .phase-content {
            display: none;
        }

        .phase-content.active {
            display: block;
        }

        /* Loading Spinner */
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #1976d2;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: static;
            }
            
            .cards-grid {
                grid-template-columns: 1fr;
            }

            /* ADD this new rule */
            .container {
                padding: 1rem;
            }
        }

        /* Phase 3 Specific CSS - Add these rules to your existing CSS file */

        /* Scenario Builder - NEW */
        .scenario-builder {
            background: #f5f7fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        /* Outcome content visibility - NEW */
        .outcome-content {
            display: none;
        }

        .outcome-content.active {
            display: block;
        }

        /* Add these CSS rules to fix the mind map layout issues */
        /* Mind map container fixes */
        #mindmap-content {
            width: 100%;
            max-width: 100%;
            overflow: visible;
            margin-bottom: 2rem; /* Add space after mind map */
            z-index: 1; /* Ensure it doesn't overlap other content */
        }

        #mindmap-visualization {
            width: 100%;
            height: 700px; /* Fixed height */
            border: 1px solid #ddd;
            margin-top: 1rem;
            margin-bottom: 2rem;
            overflow: visible;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Ensure the SVG fits properly */
        #mindmap-visualization svg {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }

        /* Fix for generated content sections */
        .generated-content {
            margin-bottom: 2rem;
            padding: 1rem;
            background: #f9f9f9;
            border-radius: 8px;
            overflow: visible;
        }

        /* Ensure form sections are properly spaced and visible */
        .form-section {
            margin-bottom: 3rem;
            clear: both;
            overflow: visible;
            z-index: auto;
        }

        /* Fix for phases 2 and 3 visibility */
        .form-section h3 {
            margin-bottom: 1rem;
            margin-top: 2rem;
            font-weight: bold;
            color: #333;
        }

        /* Ensure AI cards don't get hidden */
        .ai-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            z-index: auto;
        }

        /* Button container spacing */
        .ai-card > div[style*="display: flex"] {
            margin-bottom: 1rem;
        }

        /* Ensure content flows properly */
        body, html {
            overflow-x: auto;
            overflow-y: auto;
        }

        /* Fix any potential absolute positioning issues */
        * {
            position: relative;
        }

        /* Override any potential hidden styles */
        .form-section:not(:first-child) {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Make sure phases are visible */
        .form-section:nth-child(n+2) {
            display: block !important;
            margin-top: 2rem;
        }

        /* visioning */
        /* visioning - ONLY NEW CLASSES, NO DUPLICATES */

        /* visioning - Wind Tunnel Analysis CSS */
        
        /* ISOLATED VISIONING CSS - NO CONFLICTS */
        .visioning-wrapper {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .visioning-wrapper * {
            box-sizing: border-box;
        }

        .visioning-phase-header {
            text-align: center;
            color: #1a237e;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .visioning-phase-header h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .visioning-phase-header p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .visioning-form-section {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .visioning-form-section h3 {
            color: #1a237e;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .visioning-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
        }

        .visioning-upload-area:hover {
            border-color: #1976d2;
            background: #f5f7fa;
        }

        .visioning-upload-area.active {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .visioning-upload-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .visioning-upload-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .visioning-upload-subtext {
            color: #666;
            font-size: 0.9rem;
        }

        .visioning-status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }

        .visioning-status-success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .visioning-status-info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .visioning-wind-tunnel-section {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border: 2px solid #e3f2fd;
        }

        .visioning-wind-tunnel-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .visioning-wind-tunnel-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #1976d2, #42a5f5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            color: white;
        }

        .visioning-wind-tunnel-info h4 {
            color: #1a237e;
            font-size: 1.3rem;
            margin-bottom: 0.3rem;
        }

        .visioning-wind-tunnel-info p {
            color: #666;
            margin-bottom: 0;
            font-size: 0.95rem;
        }

        .visioning-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .visioning-btn-primary {
            background: #1976d2;
            color: white;
        }

        .visioning-btn-primary:hover {
            background: #1565c0;
        }

        .visioning-btn-ai {
            background: #673ab7;
            color: white;
            width: 100%;
            justify-content: center;
        }

        .visioning-btn-ai:hover {
            background: #5e35b1;
        }

        .visioning-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .visioning-btn-secondary {
            background: #f5f7fa;
            color: #333;
            border: 1px solid #ddd;
        }

        .visioning-btn-secondary:hover {
            background: #e0e0e0;
        }

        .visioning-loading-state {
            text-align: center;
            padding: 2rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .visioning-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #1976d2;
            border-radius: 50%;
            animation: visioningSpin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes visioningSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .visioning-loading-text {
            color: #666;
            font-size: 1rem;
        }

        .visioning-results-header {
            text-align: center;
            margin: 2rem 0;
        }

        .visioning-results-header h4 {
            color: #1a237e;
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
        }

        .visioning-results-header p {
            color: #666;
            font-size: 0.95rem;
        }

        .visioning-analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .visioning-analysis-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            border-left: 4px solid #1976d2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .visioning-analysis-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .visioning-analysis-card h5 {
            color: #1a237e;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .visioning-analysis-content {
            color: #666;
            line-height: 1.6;
        }

        .visioning-analysis-content h6 {
            color: #333;
            margin: 1rem 0 0.5rem;
            font-size: 0.95rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .visioning-analysis-content h6:first-child {
            margin-top: 0;
        }

        .visioning-analysis-content ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .visioning-analysis-content li {
            margin-bottom: 0.4rem;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .visioning-button-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 2rem;
            gap: 1rem;
        }

        .visioning-highlight-box {
            background: #fff3cd;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #ffeaa7;
            margin-bottom: 1rem;
        }

        .visioning-highlight-box p {
            margin: 0;
            color: #856404;
            font-size: 0.9rem;
        }

        /* Color variants for scenario cards */
        .visioning-analysis-card.baseline {
            border-left-color: #ff9800;
        }

        .visioning-analysis-card.collapse {
            border-left-color: #f44336;
        }

        .visioning-analysis-card.equilibrium {
            border-left-color: #2196f3;
        }

        .visioning-analysis-card.transformation {
            border-left-color: #4caf50;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .visioning-analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .visioning-button-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .visioning-phase-header h1 {
                font-size: 1.8rem;
            }
        }

        /* Add this CSS to your existing styles in index.html */

        /* Cross-scenario analysis card styling */
        .visioning-analysis-card.cross-scenario {
            background: #f8f9fa;
            border-left: 4px solid #2c3e50;
            margin-top: 2rem;
        }

        .visioning-analysis-card.cross-scenario h5 {
            color: #2c3e50;
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }

        .visioning-analysis-card.cross-scenario .visioning-analysis-content {
            color: #333;
        }

        .visioning-analysis-card.cross-scenario h6 {
            color: #2c3e50;
            font-weight: 600;
            margin: 1rem 0 0.5rem 0;
            font-size: 1rem;
        }

        .visioning-analysis-card.cross-scenario p {
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        /* Ensure the grid spans full width for cross-scenario card */
        /* Replace your existing .visioning-analysis-grid CSS with this: */

        .visioning-analysis-grid {
            display: block; /* Change from grid to block */
            margin-top: 1.5rem;
        }

        /* Make all scenario cards full width and stack vertically */
        .visioning-analysis-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            border-left: 4px solid #1976d2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            margin-bottom: 1.5rem; /* Add space between stacked cards */
            width: 100%;
        }

        /* Grid layout for the 4 sections within each scenario card */
        .visioning-analysis-content.scenario-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-top: 0;
        }

        .visioning-analysis-section {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
            border-left: 3px solid #e0e0e0;
        }

        .visioning-analysis-section h6 {
            color: #333;
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .visioning-analysis-section p {
            margin: 0;
            font-size: 0.85rem;
            line-height: 1.5;
            color: #666;
        }

        /* Color coding for different sections */
        .visioning-analysis-section.viability {
            border-left-color: #e91e63;
            background: #fce4ec;
        }

        .visioning-analysis-section.process {
            border-left-color: #9c27b0;
            background: #f3e5f5;
        }

        .visioning-analysis-section.capabilities {
            border-left-color: #2196f3;
            background: #e3f2fd;
        }

        .visioning-analysis-section.adaptations {
            border-left-color: #ff9800;
            background: #fff3e0;
        }

        /* Remove the grid-column span for cross-scenario since all cards are now full width */
        .visioning-analysis-card.cross-scenario {
            background: #f8f9fa;
            border-left: 4px solid #2c3e50;
            margin-top: 2rem;
        }

        /* Add these new section color classes to your existing CSS */

        .visioning-analysis-section.robust {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }

        .visioning-analysis-section.vulnerabilities {
            border-left-color: #ff5722;
            background: #fbe9e7;
        }

        .visioning-analysis-section.scenario-specific {
            border-left-color: #3f51b5;
            background: #e8eaf6;
        }

        .visioning-analysis-section.monitoring {
            border-left-color: #607d8b;
            background: #eceff1;
        }

        /* Better alignment for STEEPV and Futures Triangle content */
        /* Force vertical alignment for STEEPV cells */
        .matrix-cell[contenteditable="true"] {
            display: block !important;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .matrix-cell[contenteditable="true"] > div {
            display: block !important;
            width: 100%;
            margin-bottom: 8px;
            line-height: 1.6;
            clear: both;
        }

        .matrix-cell[contenteditable="true"] span.translatable {
            display: inline;
            white-space: normal;
        }

        /* Prevent float or inline-block behavior */
        #steepv-social > div,
        #steepv-technological > div,
        #steepv-economic > div,
        #steepv-environmental > div,
        #steepv-political > div,
        #steepv-values > div {
            display: block !important;
            width: 100%;
            float: none !important;
        }
         
    </style>
</head>
<body>
    <!-- Navigation -->
    <!-- <nav class="navbar">
        <div class="navbar-content">
            <div class="logo">Foresight & AI Policy Platform</div>
            <ul class="nav-links">
                <li><a href="#dashboard">Dashboard</a></li>
                <li><a href="#projects">Projects</a></li>
                <li><a href="#help">Help</a></li>
                <li><a href="#profile">Profile</a></li>
            </ul>
        </div>
    </nav> -->
    <!-- Update your navbar section -->
    <nav class="navbar">
        <div class="navbar-content">
            <div class="logo">Foresight & AI Policy Platform</div>
            <div style="display: flex; align-items: center; gap: 2rem;">
                <ul class="nav-links">
                    <li><a href="#dashboard">Dashboard</a></li>
                    <li><a href="#projects">Projects</a></li>
                    <li><a href="#help">Help</a></li>
                    <li><a href="#profile">Profile</a></li>
                </ul>
                <!-- Language Toggle Button -->
                <div class="language-toggle">
                    <button id="language-toggle-btn" class="btn btn-secondary" onclick="toggleLanguage()">
                        <span id="language-flag">üá¨üáß</span>
                        <span id="language-text">EN</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <div class="dashboard-grid">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="progress-indicator">
                    <h3>Project Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                        <span id="progress-text">0</span>% Complete
                    </p>
                </div>

                <nav class="phase-navigation">
                    <h3 style="margin-bottom: 1rem;">Framework Phases</h3>
                    <ul class="phase-list">
                        <li class="phase-item active" data-phase="1">
                            <span class="phase-icon">1</span>
                            <span>Framing</span>
                        </li>
                        <li class="phase-item" data-phase="2">
                            <span class="phase-icon">2</span>
                            <span>Horizon Scanning</span>
                        </li>
                        <li class="phase-item" data-phase="3">
                            <span class="phase-icon">3</span>
                            <span>Futuring</span>
                        </li>
                        <li class="phase-item" data-phase="4">
                            <span class="phase-icon">4</span>
                            <span>Visioning</span>
                        </li>
                        <!-- <li class="phase-item" data-phase="5">
                            <span class="phase-icon">5</span>
                            <span>Designing</span>
                        </li>
                        <li class="phase-item" data-phase="6">
                            <span class="phase-icon">6</span>
                            <span>Adapting</span>
                        </li> -->
                    </ul>
                </nav>

                <div style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #e0e0e0;">
                    <button class="btn btn-secondary" style="width: 100%;">
                        üì• Export Project
                    </button>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Phase 1: Framing -->
                <div id="phase-1" class="phase-content active">
                    <div class="content-header">
                        <h1>Phase 1: Framing</h1>
                        <p>Define the project scope, domain, and establish baseline understanding</p>
                    </div>

                    <!-- Project Setup Form -->
                    <div class="form-section">
                        <h3>Project Setup</h3>
                        <div class="form-group">
                            <label for="project-name">1. Project Name</label>
                            <input type="text" id="project-name" placeholder="Enter project name">
                        </div>
                        <div class="form-group">
                            <label for="domain-select">2. Domain Focus</label>
                            <select id="domain-select" onchange="handleDomainSelection()">
                                <option value="">Choose from past projects or create new...</option>
                                <optgroup label="Past Projects">
                                    <option value="food-security">Food Security & Self-Sufficiency in Lao PDR</option>
                                    <option value="human-capital">Human Capital & TVET Development</option>
                                    <option value="sme-fiscal">SMEs & Fiscal Policy Reform</option>
                                    <option value="renewable-energy">Renewable Energy Transition</option>
                                    <option value="digital-economy">Digital Economy Transformation</option>
                                </optgroup>
                                <option value="new">+ Create New Domain</option>
                            </select>
                        </div>
                        <div class="form-group" id="new-domain-input" style="display: none;">
                            <label for="new-domain-name">New Domain Name</label>
                            <input type="text" id="new-domain-name" placeholder="Enter new domain focus">
                        </div>
                    </div>

                    <!-- Upload Draft Domain Map -->
                    <div class="form-section">
                        <h3>3. Upload Draft Domain Map</h3>
                        <div class="upload-area" onclick="document.getElementById('domain-map-file').click()">
                            <div class="upload-icon">üó∫Ô∏è</div>
                            <p><strong>Upload existing domain map</strong></p>
                            <p style="font-size: 0.9rem; color: #666;">Supports PDF, Word, PowerPoint, or image files</p>
                            <input type="file" id="domain-map-file" style="display: none;" accept=".pdf,.doc,.docx,.ppt,.pptx,.jpg,.jpeg,.png" multiple>
                        </div>
                        <div id="domain-map-upload-status" style="margin-top: 1rem; display: none;">
                            <div class="signal-card strong">
                                <h4>‚úÖ Domain Map Uploaded</h4>
                                <p id="domain-map-filename"></p>
                                <button class="btn btn-secondary" style="margin-top: 0.5rem;" onclick="removeDomainMapUpload()">Remove</button>
                            </div>
                        </div>
                    </div>

                    <!-- AI Domain Map Generation -->
                    <div class="form-section">
                        <h3>4. Domain Map Development</h3>
                        <div class="ai-card">
                            <div class="ai-header">
                                <div>
                                    <h4>AI-Enhanced Domain Map</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Generate or refine domain map based on uploaded draft and selected focus</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <div style="display: flex; gap: 1rem;">
                                <button class="btn btn-ai" onclick="generateDomainMap()">
                                    <span>ü§ñ</span>
                                    Generate Domain Map
                                </button>
                                <!-- <button class="btn btn-secondary" onclick="refineDomainMap()" id="refine-btn" style="display: none;">
                                    <span>üîß</span>
                                    Refine Existing Map
                                </button> -->
                                <button class="btn btn-ai" onclick="generateMindMap()" id="mindmap-btn" style="display: none;">
                                    <span>üß†</span>
                                    Generate Mind Map
                                </button>
                            </div>
                            
                            <div class="generated-content" id="domain-map-content" style="display: none;"></div>
                            <div class="generated-content" id="mindmap-content" style="display: none;">
                                <h4>Domain Mind Map</h4>
                                <div id="mindmap-visualization" style="width: 100%; height: 600px; border: 1px solid #ddd; margin-top: 1rem;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Interview Data Upload -->
                    <div class="form-section">
                        <h3>5. Interview Data</h3>
                        <div class="upload-area" onclick="document.getElementById('interview-files').click()">
                            <div class="upload-icon">üé§</div>
                            <p><strong>Upload interview transcripts or summaries</strong></p>
                            <p style="font-size: 0.9rem; color: #666;">Supports PDF, Word, Excel, audio files, or transcripts</p>
                            <input type="file" id="interview-files" style="display: none;" multiple accept=".pdf,.doc,.docx,.xlsx,.xls,.txt,.mp3,.wav,.m4a">
                        </div>
                        <div id="interview-upload-list" style="margin-top: 1rem;"></div>
                        
                        <div style="margin-top: 1.5rem;">
                            <h4>Interview Analysis</h4>
                            <button class="btn btn-ai" onclick="analyzeInterviews()" id="analyze-interviews-btn" disabled>
                                <span>üìä</span>
                                Analyze Interview Data
                            </button>
                            <div id="interview-analysis" style="display: none; margin-top: 1rem;">
                                <div class="generated-content" id="interview-analysis-content"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Navigation Buttons -->
                    <!-- UPDATE: Navigation Buttons in Phase 1 -->
                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="savePhase1Progress()">
                            <span>üíæ</span>
                            Save Progress
                        </button>
                        <button class="btn btn-primary" onclick="nextPhase(2)">Continue to Scanning ‚Üí</button>
                    </div>
                </div>


                <!-- Phase 2: Horizon Scanning -->
                <div id="phase-2" class="phase-content">
                    <div class="content-header">
                        <h1>Phase 2: Horizon Scanning</h1>
                        <p>Identify signals of change using STEEPV framework and Futures Triangle</p>
                    </div>

                    <!-- Upload Signals -->
                    <div class="form-section">
                        <h3>1. Upload Signals</h3>
                        <div class="upload-area" onclick="document.getElementById('signals-upload').click()">
                            <div class="upload-icon">üì°</div>
                            <p><strong>Upload signals, trends, and emerging issues</strong></p>
                            <p style="font-size: 0.9rem; color: #666;">Supports PDF, Word, Excel, CSV, and text files</p>
                            <input type="file" id="signals-upload" style="display: none;" multiple accept=".pdf,.doc,.docx,.xlsx,.xls,.csv,.txt">
                        </div>
                        <div id="signals-upload-list" style="margin-top: 1rem;"></div>
                    </div>

                    <!-- Signals Generation -->
                    <div class="form-section">
                        <h3>2. Generate Strong & Weak Signals</h3>
                        <div class="ai-card">
                            <div class="ai-header">
                                <div>
                                    <h4>AI-Powered Signal Detection</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Generate signals using uploaded documents and interviews</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <div class="button-group" style="gap: 0.75rem; margin-top: 0;">
                                <button class="btn btn-ai" onclick="generateSignals()">
                                    <span>üîç</span>
                                    Generate Strong & Weak Signals
                                </button>
                                <button class="btn btn-secondary" onclick="generateAISuggestions()" id="ai-suggestions-btn" disabled>
                                    <span>üí°</span>
                                    Generate AI Suggestions
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Signals Tabs -->
                    <div class="form-section" id="signals-section" style="display: none;">
                        <div class="tabs" id="signals-tabs">
                            <div class="tab active" data-tab="strong">Strong Signals</div>
                            <div class="tab" data-tab="weak">Weak Signals</div>
                            <div class="tab" data-tab="ai-suggestions">AI Suggestions</div>
                        </div>
                        <div id="signals-strong" class="generated-content" style="display: none;"></div>
                        <div id="signals-weak" class="generated-content" style="display: none;"></div>
                        <div id="signals-ai" class="generated-content" style="display: none;"></div>
                    </div>

                    <!-- STEEPV Analysis -->
                    <div class="form-section">
                        <h3>3. STEEPV Analysis</h3>
                        <div class="ai-card">
                            <div class="ai-header">
                                <div>
                                    <h4>Generate STEEPV Analysis</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Automatically categorize signals using STEEPV framework</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <button class="btn btn-ai" onclick="generateSTEEPV()" id="generate-steepv-btn" disabled>
                                <span>üìä</span>
                                Generate STEEPV Analysis
                            </button>
                        </div>
                    </div>    
                    <!-- STEEPV Analysis Section - UPDATE -->
                    <div id="steepv-content" style="display: none;">
                        <div class="matrix-container">
                            <div class="matrix-grid">
                                <div class="matrix-cell matrix-header"><strong>S</strong>ocial</div>
                                <div class="matrix-cell" id="steepv-social" contenteditable="true" style="min-height: 100px; border: 1px solid #ddd; padding: 10px;">Generated social signals will appear here...</div>
                                
                                <div class="matrix-cell matrix-header"><strong>T</strong>echnological</div>
                                <div class="matrix-cell" id="steepv-technological" contenteditable="true" style="min-height: 100px; border: 1px solid #ddd; padding: 10px;">Generated technological signals will appear here...</div>
                                
                                <div class="matrix-cell matrix-header"><strong>E</strong>conomic</div>
                                <div class="matrix-cell" id="steepv-economic" contenteditable="true" style="min-height: 100px; border: 1px solid #ddd; padding: 10px;">Generated economic signals will appear here...</div>
                                
                                <div class="matrix-cell matrix-header"><strong>E</strong>nvironmental</div>
                                <div class="matrix-cell" id="steepv-environmental" contenteditable="true" style="min-height: 100px; border: 1px solid #ddd; padding: 10px;">Generated environmental signals will appear here...</div>
                                
                                <div class="matrix-cell matrix-header"><strong>P</strong>olitical</div>
                                <div class="matrix-cell" id="steepv-political" contenteditable="true" style="min-height: 100px; border: 1px solid #ddd; padding: 10px;">Generated political signals will appear here...</div>
                                
                                <div class="matrix-cell matrix-header"><strong>V</strong>alues</div>
                                <div class="matrix-cell" id="steepv-values" contenteditable="true" style="min-height: 100px; border: 1px solid #ddd; padding: 10px;">Generated values-based signals will appear here...</div>
                            </div>
                        </div>
                        
                        <!-- Save Button for STEEPV -->
                        <div style="margin-top: 1rem; text-align: center;">
                            <button class="btn btn-primary" onclick="saveSTEEPV()" id="save-steepv-btn">
                                <span>üíæ</span>
                                Save STEEPV Analysis
                            </button>
                        </div>
                    </div>

                    <!-- Futures Triangle -->
                    <div class="form-section">
                        <h3>4. Futures Triangle</h3>
                        <div class="ai-card">
                            <div class="ai-header">
                                <div>
                                    <h4>Generate Futures Triangle Analysis</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Analyze the pull of the future, push of the present, and weight of history</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <button class="btn btn-ai" onclick="generateFuturesTriangle()" id="generate-triangle-btn" disabled>
                                <span>üìä</span>
                                Generate Futures Triangle
                            </button>
                        </div>
                        
                        <!-- Futures Triangle Content - UPDATE -->
                        <div id="futures-triangle-content" style="display: none;">
                            <!-- Three Forces Cards -->
                            <div class="cards-grid">
                                <div class="card">
                                    <h4>üéØ Pull of the Future</h4>
                                    <div id="triangle-future" contenteditable="true" style="min-height: 150px; padding: 1rem; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem;">
                                        Future visions and aspirations will appear here...
                                    </div>
                                </div>
                                <div class="card">
                                    <h4>‚ö° Push of the Present</h4>
                                    <div id="triangle-present" contenteditable="true" style="min-height: 150px; padding: 1rem; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem;">
                                        Current trends and drivers will appear here...
                                    </div>
                                </div>
                                <div class="card">
                                    <h4>‚öì Weight of History</h4>
                                    <div id="triangle-past" contenteditable="true" style="min-height: 150px; padding: 1rem; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem;">
                                        Historical constraints and legacy factors will appear here...
                                    </div>
                                </div>
                            </div>

                            <!-- Key Dynamics & Strategic Insights -->
                            <div style="margin-top: 2rem;">
                                <h3>Key Dynamics & Strategic Insights</h3>
                                <div class="cards-grid">
                                    <div class="card">
                                        <h4>‚öîÔ∏è Primary Tensions</h4>
                                        <div id="dynamics-tensions" contenteditable="true" style="min-height: 120px; padding: 1rem; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem;">
                                            Main conflicts between forces will appear here...
                                        </div>
                                    </div>
                                    <div class="card">
                                        <h4>ü§ù Alignment Opportunities</h4>
                                        <div id="dynamics-alignment" contenteditable="true" style="min-height: 120px; padding: 1rem; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem;">
                                            Where forces work together will appear here...
                                        </div>
                                    </div>
                                    <div class="card">
                                        <h4>‚ùì Critical Uncertainties</h4>
                                        <div id="dynamics-uncertainties" contenteditable="true" style="min-height: 120px; padding: 1rem; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem;">
                                            What remains unknown will appear here...
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Save Button for Futures Triangle -->
                            <div style="margin-top: 1rem; text-align: center;">
                                <button class="btn btn-primary" onclick="saveFuturesTriangle()" id="save-triangle-btn">
                                    <span>üíæ</span>
                                    Save Futures Triangle
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="previousPhase(1)">‚Üê Back to Framing</button>
                        <button class="btn btn-primary" onclick="nextPhase(3)">Continue to Futuring ‚Üí</button>
                    </div>
                </div>

                <!-- Phase 3: Futuring -->
                <div id="phase-3" class="phase-content">       
                    <div class="content-header">
                        <h1>Phase 3: Futuring</h1>
                        <p>Develop drivers, uncertainties, narratives, and alternative scenarios</p>
                    </div>

                    <!-- Futures Triangle 2.0 Analysis -->
                    <div class="form-section">
                        <h3>1. Futures Triangle 2.0 Analysis</h3>
                        <div class="ai-card" style="margin-bottom: 1.5rem;">
                            <div class="ai-header">
                                <div>
                                    <h4>Generate Futures Triangle 2.0</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Analyze drivers, uncertainties, and narratives based on scanning data</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <button class="btn btn-ai" onclick="generateFuturesTriangle2()">
                                <span>üî∫</span>
                                Generate Analysis
                            </button>
                        </div>

                        <div id="futures-triangle-2-content" style="display: none;">
                            <!-- Visual Triangle Diagram -->
                            <div style="text-align: center; margin: 2rem 0;">
                                <!-- Just the corrected SVG section -->
                                <svg width="600" height="400" viewBox="0 0 600 400" style="max-width: 100%;">
                                    <!-- Triangle -->
                                    <path d="M300 50 L100 350 L500 350 Z" fill="#f5f7fa" stroke="#1976d2" stroke-width="2"/>
                                    
                                    <!-- Labels -->
                                    <text x="300" y="40" text-anchor="middle" font-weight="bold" font-size="16">Uncertainties</text>
                                    <text x="80" y="380" text-anchor="middle" font-weight="bold" font-size="16">Drivers</text>
                                    <text x="520" y="380" text-anchor="middle" font-weight="bold" font-size="16">Narratives</text>
                                    
                                    <!-- Arrow marker definition (moved up for proper rendering) -->
                                    <defs>
                                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                            <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
                                        </marker>
                                    </defs>
                                    
                                    <!-- Left arrow with repositioned text -->
                                    <path d="M150 320 Q80 250 150 180" fill="none" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                                    <text x="90" y="250" font-size="12" text-anchor="middle">Push of</text>
                                    <text x="90" y="265" font-size="12" text-anchor="middle">the Present</text>
                                    
                                    <!-- Right arrow with repositioned text -->
                                    <path d="M450 320 Q520 250 450 180" fill="none" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                                    <text x="510" y="250" font-size="12" text-anchor="middle">Pull of</text>
                                    <text x="510" y="265" font-size="12" text-anchor="middle">the Future</text>
                                    
                                    <!-- Bottom curve with repositioned text -->
                                    <path d="M180 350 Q300 370 420 350" fill="none" stroke="#333" stroke-width="2"/>
                                    <text x="300" y="385" font-size="12" text-anchor="middle">Weight of the Past</text>
                                </svg>
                            </div>

                            <!-- Content Areas -->
                            <div class="cards-grid">
                                <div class="card" style="border-top: 4px solid #e74c3c;">
                                    <h4>üîÑ Drivers</h4>
                                    <p style="font-size: 0.875rem; color: #666; margin-bottom: 1rem;">Major factors and forces (rooted in push of present and/or weight of past)</p>
                                    <div contenteditable="true" style="min-height: 150px; padding: 0.75rem; background: #f8f9fa; border-radius: 4px;" id="drivers-content">
                                        Click to add drivers...
                                    </div>
                                </div>
                                <div class="card" style="border-top: 4px solid #f39c12;">
                                    <h4>‚ùì Uncertainties</h4>
                                    <p style="font-size: 0.875rem; color: #666; margin-bottom: 1rem;">High-impact possibilities (rooted in push of present and/or pull of future)</p>
                                    <div contenteditable="true" style="min-height: 150px; padding: 0.75rem; background: #f8f9fa; border-radius: 4px;" id="uncertainties-content">
                                        Click to add uncertainties...
                                    </div>
                                </div>
                                <div class="card" style="border-top: 4px solid #9b59b6;">
                                    <h4>üìñ Narratives</h4>
                                    <p style="font-size: 0.875rem; color: #666; margin-bottom: 1rem;">Common, dominant, and/or impactful stories (rooted in weight of past or pull of future)</p>
                                    <div contenteditable="true" style="min-height: 150px; padding: 0.75rem; background: #f8f9fa; border-radius: 4px;" id="narratives-content">
                                        Click to add narratives...
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Baseline Scenario Generation -->
                    <!-- Baseline Scenario Generation -->
                    <div class="form-section">
                        <h3>2. Baseline Scenario</h3>
                        <div class="ai-card">
                            <div class="ai-header">
                                <div>
                                    <h4>Generate Baseline Scenario</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Create a continuation scenario dominated by Push of the Present and key Drivers</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <button class="btn btn-ai" onclick="generateBaselineScenario()" id="baseline-btn">
                                <span>üìà</span>
                                Generate Baseline Scenario
                            </button>
                            
                            <div class="generated-content" id="baseline-scenario-content" style="display: none; margin-top: 1rem;">
                                <!-- <button class="edit-toggle">Edit</button> -->
                                <h4 id="baseline-title"></h4>
                                <div id="baseline-text" style="margin-top: 1rem;">
                                </div>
                            </div>
                        </div>
                    </div>                     


                    <!-- Driver Outcomes -->
                    <!-- Driver Outcomes -->
                    <div class="form-section">
                        <h3>3. Driver Outcomes</h3>
                        <p style="color: #666; margin-bottom: 1rem;">Map how each driver, uncertainty, and narrative plays out across the different archetypes</p>
                        
                        <div class="ai-card">
                            <div class="ai-header">
                                <div>
                                    <h4>Generate Driver Outcomes</h4>
                                    <p style="font-size: 0.9rem; color: #666;">Bend each element to the scenario archetypes</p>
                                </div>
                                <span class="ai-badge">AI Assistant</span>
                            </div>
                            <button class="btn btn-ai" onclick="generateDriverOutcomes()" id="driver-outcomes-btn">
                                <span>üéØ</span>
                                Generate Driver Outcomes
                            </button>
                        </div>

                        <!-- Results container - initially hidden -->
                        <div id="driver-outcomes-content" style="display: none; margin-top: 1.5rem;">
                            <div id="driver-outcomes-results">
                                <!-- Generated outcomes will be inserted here by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Alternative Scenarios -->
                    <div class="form-section">
                        <h3>4. Alternative Scenarios</h3>
                        <div class="scenario-builder">
                            <h4>Scenario Configuration</h4>
                            <p>Select which archetypes and how many scenarios to generate:</p>
                            
                            <div class="cards-grid" style="margin-top: 1rem;">
                                <div class="card">
                                    <h5>Collapse</h5>
                                    <p style="font-size: 0.875rem; color: #666;">System breakdown or dysfunction</p>
                                    <select id="collapse-count">
                                        <option value="0">0 scenarios</option>
                                        <option value="1" selected>1 scenario</option>
                                        <option value="2">2 scenarios</option>
                                    </select>
                                </div>
                                <div class="card">
                                    <h5>New Equilibrium</h5>
                                    <p style="font-size: 0.875rem; color: #666;">System adaptation and compromise</p>
                                    <select id="new-equilibrium-count">
                                        <option value="0">0 scenarios</option>
                                        <option value="1" selected>1 scenario</option>
                                        <option value="2">2 scenarios</option>
                                    </select>
                                </div>
                                <div class="card">
                                    <h5>Transformation</h5>
                                    <p style="font-size: 0.875rem; color: #666;">Fundamental system change</p>
                                    <select id="transformation-count">
                                        <option value="0">0 scenarios</option>
                                        <option value="1" selected>1 scenario</option>
                                        <option value="2">2 scenarios</option>
                                    </select>
                                </div>
                            </div>

                            <button class="btn btn-ai" onclick="generateAlternativeScenarios()" id="alt-scenarios-btn" style="margin-top: 1.5rem;">
                                <span>üîÆ</span>
                                Generate Alternative Scenarios
                            </button>
                        </div>

                        <div id="alternative-scenarios-content" style="display: none; margin-top: 2rem;">
                            <!-- Alternative scenarios will be dynamically generated here -->
                        </div>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="previousPhase(2)">‚Üê Back to Horizon Scanning</button>
                        <button class="btn btn-primary" onclick="nextPhase(4)">Continue to Visioning ‚Üí</button>
                    </div>
                </div>
  
                <!-- Visioning -->
                <div id="phase-4" class="phase-content">
                    <!-- <div class="content-header"> -->
                    <div class="visioning-phase-header">
                                <h1>üå™Ô∏è Phase 4: Visioning - Wind Tunnel Analysis</h1>
                                <p>Stress test your policies against future scenarios using comprehensive evaluation framework</p>
                            </div>

                            <!-- Upload Policy Documents -->
                            <div class="visioning-form-section">
                                <h3>üìÑ 1. Upload Policy Documents</h3>
                                <div class="visioning-upload-area" onclick="document.getElementById('policy-files').click()" id="policy-upload-area">
                                    <div class="visioning-upload-icon">üìã</div>
                                    <div class="visioning-upload-text">Upload Policy Documents for Wind Tunnel Analysis</div>
                                    <div class="visioning-upload-subtext">Upload policy documents, proposals, or strategic plans to stress test against future scenarios</div>
                                    <input type="file" id="policy-files" style="display: none;" multiple accept=".pdf,.doc,.docx,.txt">
                                </div>
                                
                                <!-- Upload Status -->
                                <div id="upload-status" style="display: none;">
                                    <div class="visioning-status-indicator visioning-status-success">
                                        <span>‚úÖ</span>
                                        <span id="upload-count">0</span> policy documents uploaded successfully
                                    </div>
                                    <div id="uploaded-files-list"></div>
                                </div>
                            </div>

                            <!-- Wind Tunnel Analysis Section -->
                            <div class="visioning-wind-tunnel-section" id="wind-tunnel-section" style="display: none;">
                                <div class="visioning-wind-tunnel-header">
                                    <div class="visioning-wind-tunnel-icon">üå™Ô∏è</div>
                                    <div class="visioning-wind-tunnel-info">
                                        <h4>Wind Tunnel Policy Stress Testing</h4>
                                        <p>Comprehensive evaluation across VIABILITY, PROCESS, CAPABILITIES, and ADAPTATIONS NEEDED</p>
                                    </div>
                                </div>
                                
                                <div class="visioning-highlight-box">
                                    <p><strong>üéØ Analysis Framework:</strong> This analysis will evaluate your policies across 4 future scenarios (Baseline, Collapse, New Equilibrium, Transformation) using the comprehensive VIABILITY-PROCESS-CAPABILITIES-ADAPTATIONS framework.</p>
                                </div>

                                <button class="visioning-btn visioning-btn-ai" onclick="runWindTunnelAnalysis()" id="wind-tunnel-btn">
                                    <span>üå™Ô∏è</span>
                                    Run Wind Tunnel Analysis
                                </button>
                            </div>

                            <!-- Loading State -->
                            <div class="visioning-loading-state" id="loading-state" style="display: none;">
                                <div class="visioning-spinner"></div>
                                <div class="visioning-loading-text">Running comprehensive Wind Tunnel analysis across all scenarios...</div>
                            </div>

                            <!-- Wind Tunnel Results -->
                            <div id="wind-tunnel-results" style="display: none;">
                                <div class="visioning-results-header">
                                    <h4>Wind Tunnel Analysis Results</h4>
                                    <p>Comprehensive policy stress testing across four future scenarios</p>
                                </div>
                                <div class="visioning-analysis-grid" id="analysis-grid">
                                    <!-- Analysis cards will be generated for each scenario -->
                                </div>
                            </div>

                            <!-- Navigation Buttons -->
                            <div class="visioning-button-group">
                                <button class="visioning-btn visioning-btn-secondary" onclick="previousPhase(3)">
                                    ‚Üê Back to Futuring
                                </button>
                                <!-- <button class="visioning-btn visioning-btn-primary" onclick="nextPhase(5)" id="next-phase-btn" disabled>
                                    Continue to Designing ‚Üí
                                </button> -->
                            </div>
                        </div>


                
            </main>
    <script>
        // Global state
        let currentPhase = 1;
        let completedPhases = [];
        let uploadedFiles = {
            domainMap: null,
            documents: [],
            signals: [],
            interviews: []
        };
        let lastSignalsData = null;
        let savedSTEEPVData = null;
        let savedFuturesTriangleData = null;
        let savedPhase1Data = null;
        // for visioning
        let uploadedPolicyFiles = [];
        let windTunnelCompleted = false;

        // Translation state management
        let currentLanguage = 'en';
        let isTranslating = false;
        let originalTexts = new Map();
        let translationCache = new Map();
        let processedElements = new WeakSet(); // Use WeakSet for better memory management
        let translationTimeout = null;
        let uniqueTranslationTexts = new Set(); // NEW: Track unique texts
        let globalTextCache = new Map(); // Global cache for text normalization
        const pendingTranslations = new Map(); // Maps normalized text -> Promise
        let laoTranslations = new Map(); // Store element -> Lao content for caching

        // Phase Navigation
        document.querySelectorAll('.phase-item').forEach(item => {
            item.addEventListener('click', function() {
                const phase = parseInt(this.dataset.phase);
                switchToPhase(phase);
            });
        });

        function switchToPhase(phase) {
            // Hide all phases
            document.querySelectorAll('.phase-content').forEach(content => {
                content.classList.remove('active');
            });

            // Show selected phase
            document.getElementById(`phase-${phase}`).classList.add('active');

            // Update sidebar
            document.querySelectorAll('.phase-item').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.phase) === phase) {
                    item.classList.add('active');
                }
            });

            currentPhase = phase;
            updateProgress();
        }


        // UPDATE: Modified nextPhase function to pass saved data
        function nextPhase(phase) {
            // Mark current phase as completed
            if (!completedPhases.includes(currentPhase)) {
                completedPhases.push(currentPhase);
                document.querySelector(`.phase-item[data-phase="${currentPhase}"]`).classList.add('completed');
            }
            
            // If moving from Phase 2 (Horizon Scanning) to Phase 3 (Futuring)
            if (currentPhase === 2 && phase === 3) {
                // Pass saved data to next phase
                if (savedSTEEPVData || savedFuturesTriangleData) {
                    // Store in global variables or local storage for Phase 3 to use
                    localStorage.setItem('phase2_steepv_data', JSON.stringify(savedSTEEPVData || {}));
                    localStorage.setItem('phase2_futures_triangle_data', JSON.stringify(savedFuturesTriangleData || {}));
                }
            }
            
            switchToPhase(phase);
        }

        // ADD: Function to get saved data from Phase 2
        function getPhase2SavedData() {
            return {
                steepv_data: savedSTEEPVData || JSON.parse(localStorage.getItem('phase2_steepv_data') || '{}'),
                futures_triangle_data: savedFuturesTriangleData || JSON.parse(localStorage.getItem('phase2_futures_triangle_data') || '{}')
            };
        }

        function previousPhase(phase) {
            switchToPhase(phase);
        }

        function updateProgress() {
            const totalPhases = 4;
            const progress = (completedPhases.length / totalPhases) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = Math.round(progress);
        }

        // Domain Selection Handler
        function handleDomainSelection() {
            const select = document.getElementById('domain-select');
            const newDomainInput = document.getElementById('new-domain-input');
            
            if (select.value === 'new') {
                newDomainInput.style.display = 'block';
            } else {
                newDomainInput.style.display = 'none';
            }
        }

        // File Upload Handlers
        document.getElementById('domain-map-file').addEventListener('change', function(e) {
            const files = Array.from(e.target.files || []);
            if (files.length > 0) {
                uploadedFiles.domainMap = files[0];
                uploadedFiles.documents = files; // treat as project documents
                document.getElementById('domain-map-filename').textContent = files[0].name;
                document.getElementById('domain-map-upload-status').style.display = 'block';
                document.getElementById('refine-btn').style.display = 'inline-flex';
            }
        });

        function removeDomainMapUpload() {
            uploadedFiles.domainMap = null;
            uploadedFiles.documents = [];
            document.getElementById('domain-map-upload-status').style.display = 'none';
            document.getElementById('refine-btn').style.display = 'none';
            document.getElementById('domain-map-file').value = '';
        }

        document.getElementById('interview-files').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            uploadedFiles.interviews = uploadedFiles.interviews.concat(files);
            updateInterviewList();
        });

        function updateInterviewList() {
            const listContainer = document.getElementById('interview-upload-list');
            if (uploadedFiles.interviews.length > 0) {
                listContainer.innerHTML = uploadedFiles.interviews.map((file, index) => `
                    <div class="signal-card" style="margin-bottom: 0.5rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>üìÑ ${file.name}</span>
                            <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" 
                                    onclick="removeInterviewFile(${index})">Remove</button>
                        </div>
                    </div>
                `).join('');
                document.getElementById('analyze-interviews-btn').disabled = false;
            } else {
                listContainer.innerHTML = '';
                document.getElementById('analyze-interviews-btn').disabled = true;
            }
        }

        function removeInterviewFile(index) {
            uploadedFiles.interviews.splice(index, 1);
            updateInterviewList();
        }

        // Scanning Phase File Uploads
        document.getElementById('signals-upload').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            uploadedFiles.signals = uploadedFiles.signals || [];
            uploadedFiles.signals = uploadedFiles.signals.concat(files);
            updateSignalsList();
        });

        function updateSignalsList() {
            const listContainer = document.getElementById('signals-upload-list');
            if (uploadedFiles.signals && uploadedFiles.signals.length > 0) {
                listContainer.innerHTML = uploadedFiles.signals.map((file, index) => `
                    <div class="signal-card" style="margin-bottom: 0.5rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>üìÑ ${file.name}</span>
                            <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" 
                                    onclick="removeSignalFile(${index})">Remove</button>
                        </div>
                    </div>
                `).join('');
            } else {
                listContainer.innerHTML = '';
            }
        }

        function removeSignalFile(index) {
            uploadedFiles.signals.splice(index, 1);
            updateSignalsList();
        }

        // Add this function to your JavaScript
        function showOutcomeTab(tabName) {
            // Hide all outcome content
            document.querySelectorAll('.outcome-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected content
            const contentId = `outcomes-${tabName}`;
            const contentElement = document.getElementById(contentId);
            if (contentElement) {
                contentElement.classList.add('active');
            }
            
            // Activate clicked tab
            event.target.classList.add('active');
        }




        // visioning start here
        // File upload handling
        // File upload handling
        // File upload handling
        document.getElementById('policy-files').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            uploadedPolicyFiles = uploadedPolicyFiles.concat(files);
            updateUploadStatus();
        });

        function updateUploadStatus() {
            const uploadArea = document.getElementById('policy-upload-area');
            const uploadStatus = document.getElementById('upload-status');
            const uploadCount = document.getElementById('upload-count');
            const filesList = document.getElementById('uploaded-files-list');
            const windTunnelSection = document.getElementById('wind-tunnel-section');

            if (uploadedPolicyFiles.length > 0) {
                uploadArea.classList.add('active');
                uploadStatus.style.display = 'block';
                uploadCount.textContent = uploadedPolicyFiles.length;

                filesList.innerHTML = uploadedPolicyFiles.map((file, index) => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: white; border-radius: 4px; margin-bottom: 0.5rem; border: 1px solid #e0e0e0;">
                        <span style="font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>üìÑ</span>
                            ${file.name}
                        </span>
                        <button onclick="removeFile(${index})" style="background: #f44336; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Remove</button>
                    </div>
                `).join('');

                // Show Wind Tunnel section when files are uploaded
                windTunnelSection.style.display = 'block';
            } else {
                uploadArea.classList.remove('active');
                uploadStatus.style.display = 'none';
                filesList.innerHTML = '';
                windTunnelSection.style.display = 'none';
            }
        }

        // function removeFile(index) {
        //     uploadedPolicyFiles.splice(index, 1);
        //     updateUploadStatus();
        // }

        function removeFile(index) {
            uploadedPolicyFiles.splice(index, 1);
            
            // ADD THIS LINE: Clear the file input value
            document.getElementById('policy-files').value = '';
            
            updateUploadStatus();
        }

        // Run Wind Tunnel Analysis
        function runWindTunnelAnalysis() {
            if (uploadedPolicyFiles.length === 0) {
                alert('Please upload policy documents first before running Wind Tunnel analysis.');
                return;
            }

            // Check if we have Phase 3 data
            if (!window.savedBaselineData && !window.savedAlternativeScenarios) {
                alert('Please complete Phase 3 (Futuring) first to generate scenarios for Wind Tunnel analysis.');
                return;
            }

            const windTunnelBtn = document.getElementById('wind-tunnel-btn');
            const loadingState = document.getElementById('loading-state');
            const resultsSection = document.getElementById('wind-tunnel-results');

            // Show loading state
            windTunnelBtn.disabled = true;
            windTunnelBtn.innerHTML = '<span>‚è≥</span> Analyzing Policies...';
            loadingState.style.display = 'block';

            // Prepare Phase 3 data
            const phase3Data = {
                baseline_scenario: window.savedBaselineData || {},
                alternative_scenarios: window.savedAlternativeScenarios || {}
            };

            // Prepare form data
            const formData = new FormData();
            formData.append('domain', resolveFinalDomain());
            formData.append('project_name', document.getElementById('project-name').value.trim());
            formData.append('phase3_scenarios', JSON.stringify(phase3Data));

            // Add policy files
            uploadedPolicyFiles.forEach(file => {
                formData.append('policy_files', file);
            });

            // Make API call
            fetch('/api/wind-tunnel-analysis', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }

                // Hide loading state
                loadingState.style.display = 'none';
                resultsSection.style.display = 'block';

                // Generate and display results
                generateWindTunnelResults(data.wind_tunnel_analysis);

                // Update button
                windTunnelBtn.disabled = false;
                windTunnelBtn.innerHTML = '<span>üîÑ</span> Rerun Wind Tunnel Analysis';
                windTunnelCompleted = true;

                // added this for progress update to showing 100% complete in display
                // After successful analysis, add these lines:
                if (!completedPhases.includes(4)) {
                    completedPhases.push(4);
                    document.querySelector(`.phase-item[data-phase="4"]`).classList.add('completed');
                }
                updateProgress();

                // Enable navigation
                // document.getElementById('next-phase-btn').disabled = false;

                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth' });
            })
            .catch(error => {
                console.error('Wind Tunnel analysis error:', error);
                
                // Hide loading state
                loadingState.style.display = 'none';
                
                // Update button
                windTunnelBtn.disabled = false;
                windTunnelBtn.innerHTML = '<span>üå™Ô∏è</span> Run Wind Tunnel Analysis';
                
                // Show error
                alert(`Wind Tunnel analysis failed: ${error.message}`);
            });
        }

        function generateWindTunnelResults(analysisData) {
            const analysisGrid = document.getElementById('analysis-grid');
            
            const scenarios = analysisData.scenarios || {};
            const crossScenario = analysisData.cross_scenario || {};
            
            const scenarioNames = {
                baseline: 'Baseline Scenario',
                collapse: 'Collapse Scenario', 
                equilibrium: 'New Equilibrium',
                transformation: 'Transformation'
            };

            const scenarioIcons = {
                baseline: 'üìä',
                collapse: '‚ö†Ô∏è', 
                equilibrium: '‚öñÔ∏è',
                transformation: 'üöÄ'
            };

            let html = '';

            // Generate scenario-specific analyses
            Object.entries(scenarios).forEach(([scenarioKey, analysis]) => {
                const scenarioName = scenarioNames[scenarioKey] || scenarioKey;
                const scenarioIcon = scenarioIcons[scenarioKey] || 'üìã';
                
                html += `
                    <div class="visioning-analysis-card scenario-${scenarioKey}">
                        <h5>
                            <span>${scenarioIcon}</span>
                            ${scenarioName} Analysis
                        </h5>
                        <div class="visioning-analysis-content scenario-grid">
                            <div class="visioning-analysis-section viability">
                                <h6>üéØ VIABILITY</h6>
                                <p>${analysis.viability || 'Analysis pending...'}</p>
                            </div>
                            
                            <div class="visioning-analysis-section process">
                                <h6>‚öôÔ∏è PROCESS</h6>
                                <p>${analysis.process || 'Analysis pending...'}</p>
                            </div>
                            
                            <div class="visioning-analysis-section capabilities">
                                <h6>üí™ CAPABILITIES</h6>
                                <p>${analysis.capabilities || 'Analysis pending...'}</p>
                            </div>
                            
                            <div class="visioning-analysis-section adaptations">
                                <h6>üîÑ ADAPTATIONS NEEDED</h6>
                                <p>${analysis.adaptations_needed || 'Analysis pending...'}</p>
                            </div>
                        </div>
                    </div>
                `;
            });

            // Add cross-scenario insights
            if (crossScenario && Object.keys(crossScenario).length > 0) {
                html += `
                    <div class="visioning-analysis-card cross-scenario">
                        <h5>
                            <span>üîç</span>
                            Cross-Scenario Strategic Insights
                        </h5>
                        <div class="visioning-analysis-content scenario-grid">
                            <div class="visioning-analysis-section robust">
                                <h6>‚úÖ ROBUST ELEMENTS</h6>
                                <p>${crossScenario.robust_elements || 'Analysis pending...'}</p>
                            </div>
                            
                            <div class="visioning-analysis-section vulnerabilities">
                                <h6>‚ö†Ô∏è CRITICAL VULNERABILITIES</h6>
                                <p>${crossScenario.critical_vulnerabilities || 'Analysis pending...'}</p>
                            </div>
                            
                            <div class="visioning-analysis-section scenario-specific">
                                <h6>üéØ SCENARIO-SPECIFIC ELEMENTS</h6>
                                <p>${crossScenario.scenario_specific || 'Analysis pending...'}</p>
                            </div>
                            
                            <div class="visioning-analysis-section monitoring">
                                <h6>üìä MONITORING INDICATORS</h6>
                                <p>${crossScenario.monitoring_indicators || 'Analysis pending...'}</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            analysisGrid.innerHTML = html;
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Visioning Phase - Wind Tunnel Analysis initialized');
        });












// // zlm
// // good translation for maximum phases but missing for some parts only
//         // Translation function - only for generated content
//         async function toggleLanguage() {
//             if (isTranslating) return;
            
//             const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
//             const toggleBtn = document.getElementById('language-toggle-btn');
//             const flagSpan = document.getElementById('language-flag');
//             const textSpan = document.getElementById('language-text');
            
//             // Show loading state
//             isTranslating = true;
//             document.body.classList.add('translating');
//             toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
//             try {
//                 if (targetLanguage === 'lo') {
//                     // Translate only generated content to Lao
//                     await translateGeneratedContent();
//                     flagSpan.textContent = 'üá±üá¶';
//                     textSpan.textContent = 'LO';
//                 } else {
//                     // Restore to English
//                     restoreOriginalTexts();
//                     flagSpan.textContent = 'üá¨üáß';
//                     textSpan.textContent = 'EN';
//                 }
                
//                 currentLanguage = targetLanguage;
                
//             } catch (error) {
//                 console.error('Translation error:', error);
//                 alert('Translation failed. Please try again.');
//             } finally {
//                 isTranslating = false;
//                 document.body.classList.remove('translating');
//                 toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
//             }
//         }

//         async function translateGeneratedContent() {
//             // Comprehensive list of all generated content areas
//             const generatedContentSelectors = [
//                 // Phase 1
//                 '#domain-map-content',
//                 '#mindmap-content', 
//                 '#interview-analysis-content',
                
//                 // Phase 2
//                 '#signals-strong',
//                 '#signals-weak',
//                 '#signals-ai',
//                 '#steepv-content .matrix-cell', // STEEPV analysis cells
//                 '#futures-triangle-content .card', // Futures Triangle cards
//                 '#futures-triangle-content .card p', // Futures Triangle content
//                 '#futures-triangle-content .card div[contenteditable]', // Futures Triangle editable content
                
//                 // Phase 3
//                 '#futures-triangle-2-content',
//                 '#futures-triangle-2-content .card', // Triangle 2.0 cards
//                 '#futures-triangle-2-content [contenteditable]', // Triangle 2.0 editable content
//                 '#baseline-scenario-content',
//                 '#baseline-scenario-content h4', // Baseline title
//                 '#baseline-scenario-content p', // Baseline text
//                 '#driver-outcomes-results',
//                 '#driver-outcomes-results .card', // Driver outcomes cards
//                 '#driver-outcomes-results h4', // Driver outcomes titles
//                 '#driver-outcomes-results p', // Driver outcomes text
//                 '#alternative-scenarios-content',
//                 '#alternative-scenarios-content .card', // Alternative scenario cards
//                 '#alternative-scenarios-content h4', // Scenario titles
//                 '#alternative-scenarios-content h5', // Scenario subtitles
//                 '#alternative-scenarios-content p', // Scenario text
//                 '#alternative-scenarios-content li', // Scenario lists
                
//                 // Phase 4
//                 '#wind-tunnel-results',
//                 '#analysis-grid .visioning-analysis-card', // Wind Tunnel cards
//                 '#analysis-grid h5', // Wind Tunnel titles
//                 '#analysis-grid h6', // Wind Tunnel section titles
//                 '#analysis-grid p', // Wind Tunnel content
//                 '#analysis-grid li' // Wind Tunnel lists
//             ];
            
//             const elementsToTranslate = [];
            
//             // Collect elements from generated content areas only
//             generatedContentSelectors.forEach(selector => {
//                 const containers = document.querySelectorAll(selector);
//                 containers.forEach(container => {
//                     if (container.style.display !== 'none' && container.innerHTML.trim()) {
//                         // Get HTML content elements within generated containers
//                         const htmlElements = container.querySelectorAll('p, div, h4, h5, h6, li, td, span, strong, em, small');
//                         htmlElements.forEach(element => {
//                             const html = element.innerHTML.trim();
//                             // Only translate substantial HTML content (not UI elements)
//                             if (html && html.length > 5 && !originalTexts.has(element) && !isUIElement(element)) {
//                                 originalTexts.set(element, html);
//                                 elementsToTranslate.push(element);
//                             }
//                         });
//                     }
//                 });
//             });
            
//             // Also check for contenteditable areas with generated content
//             const editableElements = document.querySelectorAll('[contenteditable="true"]');
//             editableElements.forEach(element => {
//                 const html = element.innerHTML.trim();
//                 if (html && html.length > 5 && !html.includes('Click to add') && !originalTexts.has(element)) {
//                     originalTexts.set(element, html);
//                     elementsToTranslate.push(element);
//                 }
//             });
            
//             // Special handling for mind maps
//             const mindMapContainer = document.getElementById('mindmap-visualization');
//             if (mindMapContainer && mindMapContainer.style.display !== 'none') {
//                 const svg = mindMapContainer.querySelector('svg');
//                 if (svg && !originalTexts.has(svg)) {
//                     const textElements = svg.querySelectorAll('text');
//                     textElements.forEach(textEl => {
//                         if (textEl.textContent.trim() && !originalTexts.has(textEl)) {
//                             originalTexts.set(textEl, textEl.textContent);
//                             elementsToTranslate.push(textEl);
//                         }
//                     });
//                     originalTexts.set(svg, true); // Mark as processed
//                 }
//             }
            
//             // Translate in batches
//             const batchSize = 5; // Smaller batches for generated content
//             for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
//                 const batch = elementsToTranslate.slice(i, i + batchSize);
//                 await translateBatch(batch);
//             }
//         }

//         // Helper function to check if element is a UI element that shouldn't be translated
//         function isUIElement(element) {
//             const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
//             const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
//             // Check if element has UI class
//             if (uiClasses.some(cls => element.classList.contains(cls))) {
//                 return true;
//             }
            
//             // Check if element is a UI tag
//             if (uiTags.includes(element.tagName.toLowerCase())) {
//                 return true;
//             }
            
//             // Check if element is inside a UI element
//             if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) {
//                 return true;
//             }
            
//             return false;
//         }

//         // Add this function to preserve contenteditable attributes
//         function preserveContentEditable(container) {
//             const editableElements = container.querySelectorAll('[contenteditable="true"]');
//             editableElements.forEach(el => {
//                 el.setAttribute('data-contenteditable', 'true');
//             });
//         }

//         // Add this function to restore contenteditable attributes
//         function restoreContentEditable(container) {
//             const editableElements = container.querySelectorAll('[data-contenteditable="true"]');
//             editableElements.forEach(el => {
//                 el.setAttribute('contenteditable', 'true');
//                 el.removeAttribute('data-contenteditable');
//             });
//         }

//         // Update translateBatch to use these functions:
//         async function translateBatch(elements) {
//             const promises = elements.map(async (element) => {
//                 const originalHTML = originalTexts.get(element);
//                 if (!originalHTML) return;
                
//                 try {
//                     // Preserve contenteditable attributes before translation
//                     preserveContentEditable(element);
                    
//                     const response = await fetch('/api/translate', {
//                         method: 'POST',
//                         headers: {
//                             'Content-Type': 'application/json',
//                         },
//                         body: JSON.stringify({
//                             text: originalHTML,
//                             target_language: 'lo',
//                             mime_type: 'text/html'
//                         })
//                     });
                    
//                     const data = await response.json();
                    
//                     if (data.success && data.translated_text) {
//                         element.innerHTML = data.translated_text;
//                         // Restore contenteditable attributes after translation
//                         restoreContentEditable(element);
//                     }
//                 } catch (error) {
//                     console.error('Translation error for element:', error);
//                 }
//             });
            
//             await Promise.all(promises);
//         }

//         function restoreOriginalTexts() {
//             originalTexts.forEach((originalHTML, element) => {
//                 element.innerHTML = originalHTML;
//             });
//         }

//         // Monitor for new generated content and translate if in Lao mode
//         const observer = new MutationObserver((mutations) => {
//             if (currentLanguage === 'lo' && !isTranslating) {
//                 mutations.forEach((mutation) => {
//                     if (mutation.type === 'childList') {
//                         mutation.addedNodes.forEach((node) => {
//                             if (node.nodeType === Node.ELEMENT_NODE) {
//                                 // Comprehensive check for all generated content
//                                 const isGeneratedContent = 
//                                     node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
//                                     node.closest('#signals-strong, #signals-weak, #signals-ai') ||
//                                     node.closest('#steepv-content, #futures-triangle-content') ||
//                                     node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
//                                     node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
//                                     node.closest('#wind-tunnel-results, #analysis-grid') ||
//                                     node.id && (
//                                         node.id.includes('steepv-') || 
//                                         node.id.includes('triangle-') || 
//                                         node.id.includes('outcomes') ||
//                                         node.id === 'mindmap-visualization'
//                                     );
                                
//                                 if (isGeneratedContent) {
//                                     setTimeout(() => {
//                                         if (currentLanguage === 'lo') {
//                                             translateNewGeneratedContent(node);
//                                         }
//                                     }, 500);
//                                 }
//                             }
//                         });
//                     }
//                 });
//             }
//         });

//         async function translateNewGeneratedContent(element) {
//             // Find all translatable elements within the new content
//             const htmlElements = element.querySelectorAll('p, div, h4, h5, h6, li, td, span, strong, em, small');
//             const elementsToTranslate = [];
            
//             htmlElements.forEach(el => {
//                 const html = el.innerHTML.trim();
//                 if (html && html.length > 5 && !originalTexts.has(el) && !isUIElement(el)) {
//                     originalTexts.set(el, html);
//                     elementsToTranslate.push(el);
//                 }
//             });
            
//             // Also check for contenteditable elements
//             const editableElements = element.querySelectorAll('[contenteditable="true"]');
//             editableElements.forEach(el => {
//                 const html = el.innerHTML.trim();
//                 if (html && html.length > 5 && !html.includes('Click to add') && !originalTexts.has(el)) {
//                     originalTexts.set(el, html);
//                     elementsToTranslate.push(el);
//                 }
//             });
            
//             if (elementsToTranslate.length > 0) {
//                 await translateBatch(elementsToTranslate);
//             }
//         }

//         // Add this function to handle complex structures:
//         function translateComplexStructure(container) {
//             // Handle scenario cards
//             const scenarioCards = container.querySelectorAll('.visioning-analysis-card');
//             scenarioCards.forEach(card => {
//                 const title = card.querySelector('h5');
//                 const sections = card.querySelectorAll('.visioning-analysis-section');
                
//                 if (title && !originalTexts.has(title)) {
//                     originalTexts.set(title, title.innerHTML);
//                     translateElement(title);
//                 }
                
//                 sections.forEach(section => {
//                     const heading = section.querySelector('h6');
//                     const content = section.querySelector('p');
                    
//                     if (heading && !originalTexts.has(heading)) {
//                         originalTexts.set(heading, heading.innerHTML);
//                         translateElement(heading);
//                     }
                    
//                     if (content && !originalTexts.has(content)) {
//                         originalTexts.set(content, content.innerHTML);
//                         translateElement(content);
//                     }
//                 });
//             });
//         }

//         // Helper function to translate a single element
//         async function translateElement(element) {
//             const originalHTML = originalTexts.get(element);
//             if (!originalHTML) return;
            
//             try {
//                 const response = await fetch('/api/translate', {
//                     method: 'POST',
//                     headers: {
//                         'Content-Type': 'application/json',
//                     },
//                     body: JSON.stringify({
//                         text: originalHTML,
//                         target_language: 'lo',
//                         mime_type: 'text/html'
//                     })
//                 });
                
//                 const data = await response.json();
                
//                 if (data.success && data.translated_text) {
//                     element.innerHTML = data.translated_text;
//                 }
//             } catch (error) {
//                 console.error('Translation error for element:', error);
//             }
//         }

//         // Start observing when page loads
//         document.addEventListener('DOMContentLoaded', function() {
//             observer.observe(document.body, {
//                 childList: true,
//                 subtree: true
//             });
//         });







// by claude remove the html only sending the text also no double time loas translatio---but need to check

        // Main translation toggle function
        // async function toggleLanguage() {
        //     if (isTranslating) return;
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     // Show loading state
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             // Translate only generated content to Lao
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             // Restore to English
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
                
        //     } catch (error) {
        //         console.error('Translation error:', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
        //     }
        // }

        // async function translateGeneratedContent() {
        //     // Comprehensive list of all generated content areas
        //     const generatedContentSelectors = [
        //         // Phase 1
        //         '#domain-map-content',
        //         '#mindmap-content', 
        //         '#interview-analysis-content',
                
        //         // Phase 2
        //         '#signals-strong',
        //         '#signals-weak',
        //         '#signals-ai',
        //         '#steepv-content .matrix-cell', // STEEPV analysis cells
        //         '#futures-triangle-content .card', // Futures Triangle cards
        //         '#futures-triangle-content .card p', // Futures Triangle content
        //         '#futures-triangle-content .card div[contenteditable]', // Futures Triangle editable content
                
        //         // Phase 3
        //         '#futures-triangle-2-content',
        //         '#futures-triangle-2-content .card', // Triangle 2.0 cards
        //         '#futures-triangle-2-content [contenteditable]', // Triangle 2.0 editable content
        //         '#baseline-scenario-content',
        //         '#baseline-scenario-content h4', // Baseline title
        //         '#baseline-scenario-content p', // Baseline text
        //         '#driver-outcomes-results',
        //         '#driver-outcomes-results .card', // Driver outcomes cards
        //         '#driver-outcomes-results h4', // Driver outcomes titles
        //         '#driver-outcomes-results p', // Driver outcomes text
        //         '#alternative-scenarios-content',
        //         '#alternative-scenarios-content .card', // Alternative scenario cards
        //         '#alternative-scenarios-content h4', // Scenario titles
        //         '#alternative-scenarios-content h5', // Scenario subtitles
        //         '#alternative-scenarios-content p', // Scenario text
        //         '#alternative-scenarios-content li', // Scenario lists
                
        //         // Phase 4
        //         '#wind-tunnel-results',
        //         '#analysis-grid .visioning-analysis-card', // Wind Tunnel cards
        //         '#analysis-grid h5', // Wind Tunnel titles
        //         '#analysis-grid h6', // Wind Tunnel section titles
        //         '#analysis-grid p', // Wind Tunnel content
        //         '#analysis-grid li' // Wind Tunnel lists
        //     ];
            
        //     const elementsToTranslate = [];
            
        //     // Collect elements from generated content areas only
        //     generatedContentSelectors.forEach(selector => {
        //         const containers = document.querySelectorAll(selector);
        //         containers.forEach(container => {
        //             if (container.style.display !== 'none' && container.innerHTML.trim()) {
        //                 // Get HTML content elements within generated containers
        //                 const htmlElements = container.querySelectorAll('p, div, h4, h5, h6, li, td, span, strong, em, small');
        //                 htmlElements.forEach(element => {
        //                     const html = element.innerHTML.trim();
        //                     // Only translate substantial HTML content (not UI elements)
        //                     if (html && 
        //                         html.length > 5 && 
        //                         !originalTexts.has(element) && 
        //                         !isUIElement(element) &&
        //                         !isAlreadyTranslated(element) &&
        //                         !containsLaoScript(html)) {
                                
        //                         originalTexts.set(element, html);
        //                         elementsToTranslate.push(element);
        //                     }
        //                 });
        //             }
        //         });
        //     });
            
        //     // Also check for contenteditable areas with generated content
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         const html = element.innerHTML.trim();
        //         if (html && 
        //             html.length > 5 && 
        //             !html.includes('Click to add') && 
        //             !originalTexts.has(element) &&
        //             !containsLaoScript(html)) {
                    
        //             originalTexts.set(element, html);
        //             elementsToTranslate.push(element);
        //         }
        //     });
            
        //     // Special handling for mind maps
        //     const mindMapContainer = document.getElementById('mindmap-visualization');
        //     if (mindMapContainer && mindMapContainer.style.display !== 'none') {
        //         const svg = mindMapContainer.querySelector('svg');
        //         if (svg && !originalTexts.has(svg)) {
        //             const textElements = svg.querySelectorAll('text');
        //             textElements.forEach(textEl => {
        //                 if (textEl.textContent.trim() && 
        //                     !originalTexts.has(textEl) &&
        //                     !containsLaoScript(textEl.textContent)) {
                            
        //                     originalTexts.set(textEl, textEl.textContent);
        //                     elementsToTranslate.push(textEl);
        //                 }
        //             });
        //             originalTexts.set(svg, true); // Mark as processed
        //         }
        //     }
            
        //     // Translate in batches
        //     const batchSize = 10; // Optimized batch size
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         await translateBatch(batch);
        //     }
        // }

        // // Helper function to check if element is a UI element that shouldn't be translated
        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     // Check if element has UI class
        //     if (uiClasses.some(cls => element.classList.contains(cls))) {
        //         return true;
        //     }
            
        //     // Check if element is a UI tag
        //     if (uiTags.includes(element.tagName.toLowerCase())) {
        //         return true;
        //     }
            
        //     // Check if element is inside a UI element
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) {
        //         return true;
        //     }
            
        //     return false;
        // }

        // // Helper functions to detect already translated content
        // function isAlreadyTranslated(element) {
        //     return element.dataset.translated === 'true';
        // }

        // function containsLaoScript(text) {
        //     // Lao Unicode range: U+0E80-U+0EFF
        //     const laoPattern = /[\u0E80-\u0EFF]/;
        //     return laoPattern.test(text);
        // }

        // // Helper function to extract text from HTML
        // function extractTextFromHTML(html) {
        //     const tempDiv = document.createElement('div');
        //     tempDiv.innerHTML = html;
        //     return tempDiv.textContent || tempDiv.innerText || '';
        // }

        // // Helper function to replace text while keeping HTML structure
        // function replaceTextInHTML(originalHTML, translatedText) {
        //     const tempDiv = document.createElement('div');
        //     tempDiv.innerHTML = originalHTML;
            
        //     const walker = document.createTreeWalker(
        //         tempDiv,
        //         NodeFilter.SHOW_TEXT,
        //         null,
        //         false
        //     );
            
        //     const textNodes = [];
        //     let node;
        //     while (node = walker.nextNode()) {
        //         if (node.textContent.trim()) {
        //             textNodes.push(node);
        //         }
        //     }
            
        //     // Replace text nodes with translated text
        //     if (textNodes.length === 1) {
        //         textNodes[0].textContent = translatedText;
        //     } else if (textNodes.length > 1) {
        //         // For multiple text nodes, put all translated text in first node
        //         textNodes[0].textContent = translatedText;
        //         for (let i = 1; i < textNodes.length; i++) {
        //             textNodes[i].textContent = '';
        //         }
        //     }
            
        //     return tempDiv.innerHTML;
        // }

        // // Function to preserve contenteditable attributes
        // function preserveContentEditable(element) {
        //     const editableElements = element.querySelectorAll ? element.querySelectorAll('[contenteditable="true"]') : [];
        //     editableElements.forEach(el => {
        //         el.setAttribute('data-contenteditable', 'true');
        //     });
        // }

        // // Function to restore contenteditable attributes
        // function restoreContentEditable(element) {
        //     const editableElements = element.querySelectorAll ? element.querySelectorAll('[data-contenteditable="true"]') : [];
        //     editableElements.forEach(el => {
        //         el.setAttribute('contenteditable', 'true');
        //         el.removeAttribute('data-contenteditable');
        //     });
        // }

        // // Optimized batch translation function
        // async function translateBatch(elements) {
        //     const promises = elements.map(async (element) => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         try {
        //             // Preserve contenteditable attributes before translation
        //             if (element.querySelectorAll) {
        //                 preserveContentEditable(element);
        //             }
                    
        //             // Extract only text content for SVG text elements
        //             let textToTranslate;
        //             if (element.tagName === 'text') {
        //                 textToTranslate = originalContent; // For SVG text elements, originalContent is already text
        //             } else {
        //                 textToTranslate = extractTextFromHTML(originalContent);
        //             }
                    
        //             // Skip if no meaningful text to translate
        //             if (!textToTranslate || textToTranslate.trim().length < 3) {
        //                 return;
        //             }
                    
        //             const response = await fetch('/api/translate', {
        //                 method: 'POST',
        //                 headers: {
        //                     'Content-Type': 'application/json',
        //                 },
        //                 body: JSON.stringify({
        //                     text: textToTranslate,
        //                     target_language: 'lo',
        //                     mime_type: 'text/plain'
        //                 })
        //             });
                    
        //             const data = await response.json();
                    
        //             if (data.success && data.translated_text) {
        //                 // Handle SVG text elements differently
        //                 if (element.tagName === 'text') {
        //                     element.textContent = data.translated_text;
        //                 } else {
        //                     // Replace text while preserving HTML structure
        //                     element.innerHTML = replaceTextInHTML(originalContent, data.translated_text);
        //                     // Restore contenteditable attributes after translation
        //                     if (element.querySelectorAll) {
        //                         restoreContentEditable(element);
        //                     }
        //                 }
                        
        //                 // Mark as translated to prevent re-translation
        //                 element.dataset.translated = 'true';
        //             }
        //         } catch (error) {
        //             console.error('Translation error for element:', error);
        //         }
        //     });
            
        //     await Promise.all(promises);
        // }

        // function restoreOriginalTexts() {
        //     originalTexts.forEach((originalContent, element) => {
        //         if (element.tagName === 'text') {
        //             element.textContent = originalContent;
        //         } else {
        //             element.innerHTML = originalContent;
        //         }
        //         // Clear translation marker
        //         delete element.dataset.translated;
        //     });
        // }

        // // Monitor for new generated content and translate if in Lao mode
        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         // Add delay to prevent multiple rapid translations
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             // Comprehensive check for all generated content
        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent && !containsLaoScript(node.innerHTML)) {
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000); // Wait 1 second before translating new content
        //     }
        // });

        // async function translateNewGeneratedContent(element) {
        //     // Find all translatable elements within the new content
        //     const htmlElements = element.querySelectorAll('p, div, h4, h5, h6, li, td, span, strong, em, small');
        //     const elementsToTranslate = [];
            
        //     htmlElements.forEach(el => {
        //         const html = el.innerHTML.trim();
        //         if (html && 
        //             html.length > 5 && 
        //             !originalTexts.has(el) && 
        //             !isUIElement(el) &&
        //             !containsLaoScript(html)) {
                    
        //             originalTexts.set(el, html);
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     // Also check for contenteditable elements
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         const html = el.innerHTML.trim();
        //         if (html && 
        //             html.length > 5 && 
        //             !html.includes('Click to add') && 
        //             !originalTexts.has(el) &&
        //             !containsLaoScript(html)) {
                    
        //             originalTexts.set(el, html);
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // // Start observing when page loads
        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });


    










        // async function toggleLanguage() {
        //     if (isTranslating) return;
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     // Show loading state
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             // Translate only generated content to Lao
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             // Restore to English
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
                
        //     } catch (error) {
        //         console.error('Translation error:', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
        //     }
        // }

        // // Enhanced translation function with TEXT-ONLY extraction
        // async function translateGeneratedContent() {
        //     const elementsToTranslate = [];
            
        //     // SPECIAL HANDLING FOR DOMAIN MAP
        //     const domainMapContent = document.getElementById('domain-map-content');
        //     if (domainMapContent && domainMapContent.style.display !== 'none') {
        //         // Translate central domain title - TEXT ONLY
        //         const centralTitle = domainMapContent.querySelector('h4');
        //         if (centralTitle && !originalTexts.has(centralTitle) && !containsLaoScript(centralTitle.textContent)) {
        //             originalTexts.set(centralTitle, centralTitle.textContent.trim());
        //             elementsToTranslate.push(centralTitle);
        //         }
                
        //         // Translate central domain description - TEXT ONLY
        //         const centralDesc = domainMapContent.querySelector('p > em, p > i');
        //         if (centralDesc && !originalTexts.has(centralDesc) && !containsLaoScript(centralDesc.textContent)) {
        //             originalTexts.set(centralDesc, centralDesc.textContent.trim());
        //             elementsToTranslate.push(centralDesc);
        //         }
                
        //         // Translate each sub-domain card
        //         const subDomainCards = domainMapContent.querySelectorAll('.card, [class*="border"]');
        //         subDomainCards.forEach(card => {
        //             // Sub-domain title
        //             const title = card.querySelector('h5, strong');
        //             if (title && !originalTexts.has(title) && !containsLaoScript(title.textContent)) {
        //                 originalTexts.set(title, title.textContent.trim());
        //                 elementsToTranslate.push(title);
        //             }
                    
        //             // Sub-domain description paragraphs - TEXT ONLY
        //             const paragraphs = card.querySelectorAll('p');
        //             paragraphs.forEach(p => {
        //                 const text = p.textContent.trim();
        //                 // Skip labels like "Relevance:" or "Issue Areas:"
        //                 if (!text.includes('Relevance:') && 
        //                     !text.includes('Issue Areas:') &&
        //                     !text.includes('<') && // Skip if contains HTML
        //                     text.length > 10 &&
        //                     !originalTexts.has(p) && 
        //                     !containsLaoScript(text)) {
        //                     originalTexts.set(p, text);
        //                     elementsToTranslate.push(p);
        //                 }
        //             });
                    
        //             // Translate ONLY list items individually - TEXT ONLY
        //             const issueItems = card.querySelectorAll('li');
        //             issueItems.forEach(item => {
        //                 const text = item.textContent.trim();
        //                 if (text && 
        //                     !originalTexts.has(item) && 
        //                     !containsLaoScript(text)) {
        //                     originalTexts.set(item, text);
        //                     elementsToTranslate.push(item);
        //                 }
        //             });
                    
        //             // Translate labels separately
        //             const labels = card.querySelectorAll('strong');
        //             labels.forEach(label => {
        //                 const text = label.textContent.trim();
        //                 if ((text.includes('Relevance:') || text.includes('Issue Areas:')) &&
        //                     !originalTexts.has(label) &&
        //                     !containsLaoScript(text)) {
        //                     originalTexts.set(label, text);
        //                     elementsToTranslate.push(label);
        //                 }
        //             });
        //         });
        //     }
            
        //     // HANDLE OTHER CONTENT AREAS
        //     const otherContentSelectors = [
        //         '#mindmap-content', 
        //         '#interview-analysis-content',
        //         '#signals-strong',
        //         '#signals-weak',
        //         '#signals-ai',
        //         '#steepv-content .matrix-cell',
        //         '#futures-triangle-content .card',
        //         '#futures-triangle-2-content',
        //         '#baseline-scenario-content',
        //         '#driver-outcomes-results',
        //         '#alternative-scenarios-content',
        //         '#wind-tunnel-results',
        //         '#analysis-grid .visioning-analysis-card'
        //     ];
            
        //     otherContentSelectors.forEach(selector => {
        //         const containers = document.querySelectorAll(selector);
        //         containers.forEach(container => {
        //             if (container.style.display !== 'none') {
        //                 const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, td');
        //                 htmlElements.forEach(element => {
        //                     const text = element.textContent.trim();
        //                     if (text && 
        //                         text.length > 5 && 
        //                         !originalTexts.has(element) && 
        //                         !isUIElement(element) &&
        //                         !containsLaoScript(text)) {
                                
        //                         originalTexts.set(element, text);
        //                         elementsToTranslate.push(element);
        //                     }
        //                 });
        //             }
        //         });
        //     });
            
        //     // Handle contenteditable areas
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         const text = element.textContent.trim();
        //         if (text && 
        //             text.length > 5 && 
        //             !text.includes('Click to add') && 
        //             !originalTexts.has(element) &&
        //             !containsLaoScript(text)) {
                    
        //             originalTexts.set(element, text);
        //             elementsToTranslate.push(element);
        //         }
        //     });
            
        //     // Handle mind maps
        //     const mindMapContainer = document.getElementById('mindmap-visualization');
        //     if (mindMapContainer && mindMapContainer.style.display !== 'none') {
        //         const svg = mindMapContainer.querySelector('svg');
        //         if (svg && !originalTexts.has(svg)) {
        //             const textElements = svg.querySelectorAll('text');
        //             textElements.forEach(textEl => {
        //                 const text = textEl.textContent.trim();
        //                 if (text && 
        //                     !originalTexts.has(textEl) &&
        //                     !containsLaoScript(text)) {
                            
        //                     originalTexts.set(textEl, text);
        //                     elementsToTranslate.push(textEl);
        //                 }
        //             });
        //             originalTexts.set(svg, true);
        //         }
        //     }
            
        //     // Translate in batches
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         await translateBatch(batch);
        //     }
        // }

        // // Helper function to check if element is a UI element that shouldn't be translated
        // // Helper to check if element is UI
        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     if (uiClasses.some(cls => element.classList.contains(cls))) {
        //         return true;
        //     }
            
        //     if (uiTags.includes(element.tagName.toLowerCase())) {
        //         return true;
        //     }
            
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) {
        //         return true;
        //     }
            
        //     return false;
        // }

        // function containsLaoScript(text) {
        //     const laoPattern = /[\u0E80-\u0EFF]/;
        //     return laoPattern.test(text);
        // }

        // // Helper functions to detect already translated content
        // function isAlreadyTranslated(element) {
        //     return element.dataset.translated === 'true';
        // }

        // function containsLaoScript(text) {
        //     // Lao Unicode range: U+0E80-U+0EFF
        //     const laoPattern = /[\u0E80-\u0EFF]/;
        //     return laoPattern.test(text);
        // }

        // // Helper function to extract text from HTML
        // function extractTextFromHTML(html) {
        //     const tempDiv = document.createElement('div');
        //     tempDiv.innerHTML = html;
        //     return tempDiv.textContent || tempDiv.innerText || '';
        // }

        // // Helper function to replace text while keeping HTML structure
        // function replaceTextInHTML(originalHTML, translatedText) {
        //     const tempDiv = document.createElement('div');
        //     tempDiv.innerHTML = originalHTML;
            
        //     const walker = document.createTreeWalker(
        //         tempDiv,
        //         NodeFilter.SHOW_TEXT,
        //         null,
        //         false
        //     );
            
        //     const textNodes = [];
        //     let node;
        //     while (node = walker.nextNode()) {
        //         if (node.textContent.trim()) {
        //             textNodes.push(node);
        //         }
        //     }
            
        //     // Replace text nodes with translated text
        //     if (textNodes.length === 1) {
        //         textNodes[0].textContent = translatedText;
        //     } else if (textNodes.length > 1) {
        //         // For multiple text nodes, put all translated text in first node
        //         textNodes[0].textContent = translatedText;
        //         for (let i = 1; i < textNodes.length; i++) {
        //             textNodes[i].textContent = '';
        //         }
        //     }
            
        //     return tempDiv.innerHTML;
        // }

        // // Function to preserve contenteditable attributes
        // function preserveContentEditable(element) {
        //     const editableElements = element.querySelectorAll ? element.querySelectorAll('[contenteditable="true"]') : [];
        //     editableElements.forEach(el => {
        //         el.setAttribute('data-contenteditable', 'true');
        //     });
        // }

        // // Function to restore contenteditable attributes
        // function restoreContentEditable(element) {
        //     const editableElements = element.querySelectorAll ? element.querySelectorAll('[data-contenteditable="true"]') : [];
        //     editableElements.forEach(el => {
        //         el.setAttribute('contenteditable', 'true');
        //         el.removeAttribute('data-contenteditable');
        //     });
        // }

        // // Optimized batch translation function
        // // Updated batch translation - SENDS ONLY TEXT
        // async function translateBatch(elements) {
        //     const promises = elements.map(async (element) => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         try {
        //             // CRITICAL: Extract ONLY text, no HTML tags
        //             let textToTranslate = originalContent;
                    
        //             // If it's a string that might contain HTML, strip it
        //             if (typeof textToTranslate === 'string') {
        //                 // Remove any HTML tags that might have snuck in
        //                 const tempDiv = document.createElement('div');
        //                 tempDiv.innerHTML = textToTranslate;
        //                 textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
        //                 textToTranslate = textToTranslate.trim();
        //             }
                    
        //             if (!textToTranslate || textToTranslate.length < 3) {
        //                 return;
        //             }
                    
        //             // Double-check: if text still contains HTML tags, skip it
        //             if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
        //                 console.warn('Skipping element with HTML tags:', textToTranslate.substring(0, 50));
        //                 return;
        //             }
                    
        //             const response = await fetch('/api/translate', {
        //                 method: 'POST',
        //                 headers: {
        //                     'Content-Type': 'application/json',
        //                 },
        //                 body: JSON.stringify({
        //                     text: textToTranslate,  // Pure text only
        //                     target_language: 'lo',
        //                     source_language: 'en'
        //                 })
        //             });
                    
        //             const data = await response.json();
                    
        //             if (data.success && data.translated_text) {
        //                 // Replace ONLY the text content, preserve all HTML structure
        //                 element.textContent = data.translated_text;
        //                 element.dataset.translated = 'true';
        //             }
        //         } catch (error) {
        //             console.error('Translation error for element:', error);
        //         }
        //     });
            
        //     await Promise.all(promises);
        // }

        // function restoreOriginalTexts() {
        //     originalTexts.forEach((originalContent, element) => {
        //         if (element.tagName === 'svg') return; // Skip SVG marker
        //         element.textContent = originalContent;
        //         delete element.dataset.translated;
        //     });
        // }



        // // Monitor for new generated content and translate if in Lao mode
        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         // Add delay to prevent multiple rapid translations
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             // Comprehensive check for all generated content
        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent && !containsLaoScript(node.innerHTML)) {
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000); // Wait 1 second before translating new content
        //     }
        // });

        // async function translateNewGeneratedContent(element) {
        //     // Find all translatable elements within the new content
        //     const htmlElements = element.querySelectorAll('p, div, h4, h5, h6, li, td, span, strong, em, small');
        //     const elementsToTranslate = [];
            
        //     htmlElements.forEach(el => {
        //         const html = el.innerHTML.trim();
        //         if (html && 
        //             html.length > 5 && 
        //             !originalTexts.has(el) && 
        //             !isUIElement(el) &&
        //             !containsLaoScript(html)) {
                    
        //             originalTexts.set(el, html);
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     // Also check for contenteditable elements
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         const html = el.innerHTML.trim();
        //         if (html && 
        //             html.length > 5 && 
        //             !html.includes('Click to add') && 
        //             !originalTexts.has(el) &&
        //             !containsLaoScript(html)) {
                    
        //             originalTexts.set(el, html);
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // // Start observing when page loads
        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });
















// domain map working little bit good but the sub domain description was still in english
        // async function toggleLanguage() {
        //     if (isTranslating) return;
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
                
        //     } catch (error) {
        //         console.error('Translation error:', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
        //     }
        // }

        // async function translateGeneratedContent() {
        //     const elementsToTranslate = [];
            
        //     // DOMAIN MAP - PRECISE TARGETING
        //     const domainMapContent = document.getElementById('domain-map-content');
        //     if (domainMapContent && domainMapContent.style.display !== 'none') {
                
        //         // 1. Central domain title (the h4 or main title)
        //         const centralTitle = domainMapContent.querySelector('h4, h3, .domain-title');
        //         if (centralTitle && !originalTexts.has(centralTitle)) {
        //             const text = centralTitle.textContent.trim();
        //             if (text && !containsLaoScript(text)) {
        //                 originalTexts.set(centralTitle, text);
        //                 elementsToTranslate.push(centralTitle);
        //             }
        //         }
                
        //         // 2. Central domain description (usually italic/em text)
        //         const italicTexts = domainMapContent.querySelectorAll('em, i');
        //         italicTexts.forEach(el => {
        //             if (!originalTexts.has(el)) {
        //                 const text = el.textContent.trim();
        //                 if (text && text.length > 20 && !containsLaoScript(text)) {
        //                     originalTexts.set(el, text);
        //                     elementsToTranslate.push(el);
        //                 }
        //             }
        //         });
                
        //         // 3. "Sub-domains:" label
        //         const allStrong = domainMapContent.querySelectorAll('strong');
        //         allStrong.forEach(strong => {
        //             const text = strong.textContent.trim();
        //             if (text === 'Sub-domains:' && !originalTexts.has(strong) && !containsLaoScript(text)) {
        //                 originalTexts.set(strong, text);
        //                 elementsToTranslate.push(strong);
        //             }
        //         });
                
        //         // 4. Find all sub-domain cards more precisely
        //         // Look for divs with border or card styling that contain the sub-domain info
        //         const allDivs = domainMapContent.querySelectorAll('div[style*="border"], div.card, div[class*="border"]');
                
        //         allDivs.forEach(card => {
        //             // Skip if already processed
        //             if (card.dataset.translationProcessed === 'true') return;
        //             card.dataset.translationProcessed = 'true';
                    
        //             // Get all direct children to process them individually
        //             const children = Array.from(card.children);
                    
        //             children.forEach(child => {
        //                 // Sub-domain title (usually first strong or h5)
        //                 if (child.tagName === 'H5' || (child.tagName === 'STRONG' && child.textContent.length < 100)) {
        //                     if (!originalTexts.has(child)) {
        //                         const text = child.textContent.trim();
        //                         if (text && !containsLaoScript(text) && 
        //                             text !== 'Relevance:' && text !== 'Issue Areas:') {
        //                             originalTexts.set(child, text);
        //                             elementsToTranslate.push(child);
        //                         }
        //                     }
        //                 }
                        
        //                 // Paragraphs - but get text nodes only
        //                 if (child.tagName === 'P') {
        //                     const pText = child.textContent.trim();
                            
        //                     // Skip if it's just labels
        //                     if (pText.startsWith('Relevance:') || pText.startsWith('Issue Areas:')) {
        //                         // Translate just the label part
        //                         const labelStrong = child.querySelector('strong');
        //                         if (labelStrong && !originalTexts.has(labelStrong)) {
        //                             const labelText = labelStrong.textContent.trim();
        //                             if (!containsLaoScript(labelText)) {
        //                                 originalTexts.set(labelStrong, labelText);
        //                                 elementsToTranslate.push(labelStrong);
        //                             }
        //                         }
        //                     } else if (pText.length > 20 && !originalTexts.has(child)) {
        //                         // It's a description paragraph
        //                         if (!containsLaoScript(pText)) {
        //                             originalTexts.set(child, pText);
        //                             elementsToTranslate.push(child);
        //                         }
        //                     }
        //                 }
                        
        //                 // Lists - get individual items
        //                 if (child.tagName === 'UL' || child.tagName === 'OL') {
        //                     const listItems = child.querySelectorAll('li');
        //                     listItems.forEach(li => {
        //                         if (!originalTexts.has(li)) {
        //                             const text = li.textContent.trim();
        //                             if (text && !containsLaoScript(text)) {
        //                                 originalTexts.set(li, text);
        //                                 elementsToTranslate.push(li);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         });
        //     }
            
        //     // OTHER CONTENT AREAS
        //     const otherContentSelectors = [
        //         '#mindmap-content', 
        //         '#interview-analysis-content',
        //         '#signals-strong',
        //         '#signals-weak',
        //         '#signals-ai',
        //         '#steepv-content .matrix-cell',
        //         '#futures-triangle-content .card',
        //         '#futures-triangle-2-content',
        //         '#baseline-scenario-content',
        //         '#driver-outcomes-results',
        //         '#alternative-scenarios-content',
        //         '#wind-tunnel-results',
        //         '#analysis-grid .visioning-analysis-card'
        //     ];
            
        //     otherContentSelectors.forEach(selector => {
        //         const containers = document.querySelectorAll(selector);
        //         containers.forEach(container => {
        //             if (container.style.display !== 'none') {
        //                 const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, td');
        //                 htmlElements.forEach(element => {
        //                     if (!originalTexts.has(element)) {
        //                         const text = element.textContent.trim();
        //                         if (text && text.length > 5 && !isUIElement(element) && !containsLaoScript(text)) {
        //                             originalTexts.set(element, text);
        //                             elementsToTranslate.push(element);
        //                         }
        //                     }
        //                 });
        //             }
        //         });
        //     });
            
        //     // Contenteditable areas
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         const text = element.textContent.trim();
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(element) && !containsLaoScript(text)) {
        //             originalTexts.set(element, text);
        //             elementsToTranslate.push(element);
        //         }
        //     });
            
        //     // Mind maps
        //     const mindMapContainer = document.getElementById('mindmap-visualization');
        //     if (mindMapContainer && mindMapContainer.style.display !== 'none') {
        //         const svg = mindMapContainer.querySelector('svg');
        //         if (svg && !originalTexts.has(svg)) {
        //             const textElements = svg.querySelectorAll('text');
        //             textElements.forEach(textEl => {
        //                 const text = textEl.textContent.trim();
        //                 if (text && !originalTexts.has(textEl) && !containsLaoScript(text)) {
        //                     originalTexts.set(textEl, text);
        //                     elementsToTranslate.push(textEl);
        //                 }
        //             });
        //             originalTexts.set(svg, true);
        //         }
        //     }
            
        //     // Translate in batches
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         await translateBatch(batch);
        //     }
        // }

        // async function translateBatch(elements) {
        //     const promises = elements.map(async (element) => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         try {
        //             let textToTranslate = originalContent;
                    
        //             // Ensure it's pure text
        //             if (typeof textToTranslate === 'string') {
        //                 const tempDiv = document.createElement('div');
        //                 tempDiv.innerHTML = textToTranslate;
        //                 textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
        //                 textToTranslate = textToTranslate.trim();
        //             }
                    
        //             if (!textToTranslate || textToTranslate.length < 3) return;
                    
        //             // Skip if contains HTML
        //             if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
        //                 console.warn('Skipping HTML:', textToTranslate.substring(0, 50));
        //                 return;
        //             }
                    
        //             const response = await fetch('/api/translate', {
        //                 method: 'POST',
        //                 headers: { 'Content-Type': 'application/json' },
        //                 body: JSON.stringify({
        //                     text: textToTranslate,
        //                     target_language: 'lo',
        //                     source_language: 'en'
        //                 })
        //             });
                    
        //             const data = await response.json();
                    
        //             if (data.success && data.translated_text) {
        //                 element.textContent = data.translated_text;
        //                 element.dataset.translated = 'true';
        //             }
        //         } catch (error) {
        //             console.error('Translation error:', error);
        //         }
        //     });
            
        //     await Promise.all(promises);
        // }

        // function restoreOriginalTexts() {
        //     originalTexts.forEach((originalContent, element) => {
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') return;
        //         element.textContent = originalContent;
        //         delete element.dataset.translated;
        //     });
            
        //     // Clear processing markers
        //     document.querySelectorAll('[data-translation-processed]').forEach(el => {
        //         delete el.dataset.translationProcessed;
        //     });
        // }

        // // FIXED: translateNewGeneratedContent now uses textContent
        // async function translateNewGeneratedContent(element) {
        //     const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
        //     const elementsToTranslate = [];
            
        //     htmlElements.forEach(el => {
        //         if (!originalTexts.has(el) && !isUIElement(el)) {
        //             const text = el.textContent.trim();  // ‚úÖ FIXED: Use textContent
        //             if (text && text.length > 5 && !containsLaoScript(text)) {
        //                 originalTexts.set(el, text);  // ‚úÖ FIXED: Store text only
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });
            
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         const text = el.textContent.trim();  // ‚úÖ FIXED
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(el) && !containsLaoScript(text)) {
        //             originalTexts.set(el, text);  // ‚úÖ FIXED
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     if (uiClasses.some(cls => element.classList.contains(cls))) return true;
        //     if (uiTags.includes(element.tagName.toLowerCase())) return true;
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) return true;
            
        //     return false;
        // }

        // function containsLaoScript(text) {
        //     return /[\u0E80-\u0EFF]/.test(text);
        // }

        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent && !containsLaoScript(node.textContent)) {
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000);
        //     }
        // });

        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });









// good , the domain map was fully converted into laos language with same structure 

        // async function toggleLanguage() {
        //     if (isTranslating) return;
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
                
        //     } catch (error) {
        //         console.error('Translation error:', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
        //     }
        // }

        // async function translateGeneratedContent() {
        //     const elementsToTranslate = [];
            
        //     // DOMAIN MAP - PRECISE TARGETING
        //     const domainMapContent = document.getElementById('domain-map-content');
        //     if (domainMapContent && domainMapContent.style.display !== 'none') {
                
        //         // 1. Central domain title (the h4 or main title)
        //         const centralTitle = domainMapContent.querySelector('h4, h3, .domain-title');
        //         if (centralTitle && !originalTexts.has(centralTitle)) {
        //             const text = centralTitle.textContent.trim();
        //             if (text && !containsLaoScript(text)) {
        //                 originalTexts.set(centralTitle, text);
        //                 elementsToTranslate.push(centralTitle);
        //             }
        //         }
                
        //         // 2. Central domain description (usually italic/em text)
        //         const italicTexts = domainMapContent.querySelectorAll('em, i');
        //         italicTexts.forEach(el => {
        //             if (!originalTexts.has(el)) {
        //                 const text = el.textContent.trim();
        //                 if (text && text.length > 20 && !containsLaoScript(text)) {
        //                     originalTexts.set(el, text);
        //                     elementsToTranslate.push(el);
        //                 }
        //             }
        //         });
                
        //         // 3. "Sub-domains:" label
        //         const allStrong = domainMapContent.querySelectorAll('strong');
        //         allStrong.forEach(strong => {
        //             const text = strong.textContent.trim();
        //             if (text === 'Sub-domains:' && !originalTexts.has(strong) && !containsLaoScript(text)) {
        //                 originalTexts.set(strong, text);
        //                 elementsToTranslate.push(strong);
        //             }
        //         });
                
        //         // 4. Find all sub-domain cards more precisely
        //         const allDivs = domainMapContent.querySelectorAll('div[style*="border"], div.card, div[class*="border"]');
                
        //         allDivs.forEach(card => {
        //             // Skip if already processed
        //             if (card.dataset.translationProcessed === 'true') return;
        //             card.dataset.translationProcessed = 'true';
                    
        //             // Get all direct children to process them individually
        //             const children = Array.from(card.children);
                    
        //             children.forEach(child => {
        //                 // Sub-domain title (usually first strong or h5)
        //                 if (child.tagName === 'H5' || (child.tagName === 'STRONG' && child.textContent.length < 100)) {
        //                     if (!originalTexts.has(child)) {
        //                         const text = child.textContent.trim();
        //                         if (text && !containsLaoScript(text) && 
        //                             text !== 'Relevance:' && text !== 'Issue Areas:') {
        //                             originalTexts.set(child, text);
        //                             elementsToTranslate.push(child);
        //                         }
        //                     }
        //                 }
                        
        //                 // FIXED: Paragraphs - handle both labels and descriptions
        //                 // Paragraphs - handle ALL paragraphs including descriptions
        //                 if (child.tagName === 'P') {
        //                     const pText = child.textContent.trim();
                            
        //                     // Check for labels like "Relevance:" or "Issue Areas:"
        //                     if (pText.includes('Relevance:') || pText.includes('Issue Areas:')) {
        //                         // Translate the label part
        //                         const labelStrong = child.querySelector('strong');
        //                         if (labelStrong && !originalTexts.has(labelStrong)) {
        //                             const labelText = labelStrong.textContent.trim();
        //                             if (!containsLaoScript(labelText)) {
        //                                 originalTexts.set(labelStrong, labelText);
        //                                 elementsToTranslate.push(labelStrong);
        //                             }
        //                         }
                                
        //                         // Also get the text after the label (the actual content)
        //                         const textAfterLabel = pText.split(':').slice(1).join(':').trim();
        //                         if (textAfterLabel && textAfterLabel.length > 10 && !containsLaoScript(textAfterLabel)) {
        //                             // Store the whole paragraph for translation
        //                             if (!originalTexts.has(child)) {
        //                                 originalTexts.set(child, pText);
        //                                 elementsToTranslate.push(child);
        //                             }
        //                         }
        //                     } else if (pText.length > 10 && !originalTexts.has(child) && !containsLaoScript(pText)) {
        //                         // Regular description paragraph - translate it
        //                         originalTexts.set(child, pText);
        //                         elementsToTranslate.push(child);
        //                     }
        //                 }
                        
        //                 // Lists - get individual items
        //                 if (child.tagName === 'UL' || child.tagName === 'OL') {
        //                     const listItems = child.querySelectorAll('li');
        //                     listItems.forEach(li => {
        //                         if (!originalTexts.has(li)) {
        //                             const text = li.textContent.trim();
        //                             if (text && !containsLaoScript(text)) {
        //                                 originalTexts.set(li, text);
        //                                 elementsToTranslate.push(li);
        //                             }
        //                         }
        //                     });
        //                 }
        //                 // i think it was important
        //                 // added this extra , without adding this it was working by adding that 4 line updates in render domain map function
        //                 // Add after processing list items
        //                 // Process subdomain descriptions specifically
        //                 const subdomainDescriptions = domainMapContent.querySelectorAll('p.subdomain-description');
        //                 subdomainDescriptions.forEach(desc => {
        //                     if (!originalTexts.has(desc)) {
        //                         const text = desc.textContent.trim();
        //                         if (text && !containsLaoScript(text)) {
        //                             originalTexts.set(desc, text);
        //                             elementsToTranslate.push(desc);
        //                         }
        //                     }
        //                 });

        //             });
        //         });
        //     }
            
        //     // OTHER CONTENT AREAS
        //     const otherContentSelectors = [
        //         '#mindmap-content', 
        //         '#interview-analysis-content',
        //         '#signals-strong',
        //         '#signals-weak',
        //         '#signals-ai',
        //         '#steepv-content .matrix-cell',
        //         '#futures-triangle-content .card',
        //         '#futures-triangle-2-content',
        //         '#baseline-scenario-content',
        //         '#driver-outcomes-results',
        //         '#alternative-scenarios-content',
        //         '#wind-tunnel-results',
        //         '#analysis-grid .visioning-analysis-card'
        //     ];
            
        //     otherContentSelectors.forEach(selector => {
        //         const containers = document.querySelectorAll(selector);
        //         containers.forEach(container => {
        //             if (container.style.display !== 'none') {
        //                 const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, td');
        //                 htmlElements.forEach(element => {
        //                     if (!originalTexts.has(element)) {
        //                         const text = element.textContent.trim();
        //                         if (text && text.length > 5 && !isUIElement(element) && !containsLaoScript(text)) {
        //                             originalTexts.set(element, text);
        //                             elementsToTranslate.push(element);
        //                         }
        //                     }
        //                 });
        //             }
        //         });
        //     });
            
        //     // Contenteditable areas
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         const text = element.textContent.trim();
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(element) && !containsLaoScript(text)) {
        //             originalTexts.set(element, text);
        //             elementsToTranslate.push(element);
        //         }
        //     });
            
        //     // Mind maps
        //     const mindMapContainer = document.getElementById('mindmap-visualization');
        //     if (mindMapContainer && mindMapContainer.style.display !== 'none') {
        //         const svg = mindMapContainer.querySelector('svg');
        //         if (svg && !originalTexts.has(svg)) {
        //             const textElements = svg.querySelectorAll('text');
        //             textElements.forEach(textEl => {
        //                 const text = textEl.textContent.trim();
        //                 if (text && !originalTexts.has(textEl) && !containsLaoScript(text)) {
        //                     originalTexts.set(textEl, text);
        //                     elementsToTranslate.push(textEl);
        //                 }
        //             });
        //             originalTexts.set(svg, true);
        //         }
        //     }
            
        //     // Translate in batches
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         await translateBatch(batch);
        //     }
        // }

        // async function translateBatch(elements) {
        //     const promises = elements.map(async (element) => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         try {
        //             let textToTranslate = originalContent;
                    
        //             // Ensure it's pure text
        //             if (typeof textToTranslate === 'string') {
        //                 const tempDiv = document.createElement('div');
        //                 tempDiv.innerHTML = textToTranslate;
        //                 textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
        //                 textToTranslate = textToTranslate.trim();
        //             }
                    
        //             if (!textToTranslate || textToTranslate.length < 3) return;
                    
        //             // Skip if contains HTML
        //             if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
        //                 console.warn('Skipping HTML:', textToTranslate.substring(0, 50));
        //                 return;
        //             }
                    
        //             const response = await fetch('/api/translate', {
        //                 method: 'POST',
        //                 headers: { 'Content-Type': 'application/json' },
        //                 body: JSON.stringify({
        //                     text: textToTranslate,
        //                     target_language: 'lo',
        //                     source_language: 'en'
        //                 })
        //             });
                    
        //             const data = await response.json();
                    
        //             if (data.success && data.translated_text) {
        //                 // NEW: Handle text nodes differently
        //                 if (element.nodeType === Node.TEXT_NODE) {
        //                     element.textContent = data.translated_text;
        //                 } else {
        //                     element.textContent = data.translated_text;
        //                 }
        //                 element.dataset.translated = 'true';
        //             }
        //         } catch (error) {
        //             console.error('Translation error:', error);
        //         }
        //     });
            
        //     await Promise.all(promises);
        // }

        // function restoreOriginalTexts() {
        //     originalTexts.forEach((originalContent, element) => {
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') return;
        //         element.textContent = originalContent;
        //         delete element.dataset.translated;
        //     });
            
        //     // Clear processing markers
        //     document.querySelectorAll('[data-translation-processed]').forEach(el => {
        //         delete el.dataset.translationProcessed;
        //     });
        // }

        // // FIXED: translateNewGeneratedContent now uses textContent
        // async function translateNewGeneratedContent(element) {
        //     const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
        //     const elementsToTranslate = [];
            
        //     htmlElements.forEach(el => {
        //         if (!originalTexts.has(el) && !isUIElement(el)) {
        //             const text = el.textContent.trim();  // ‚úÖ FIXED: Use textContent
        //             if (text && text.length > 5 && !containsLaoScript(text)) {
        //                 originalTexts.set(el, text);  // ‚úÖ FIXED: Store text only
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });
            
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         const text = el.textContent.trim();  // ‚úÖ FIXED
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(el) && !containsLaoScript(text)) {
        //             originalTexts.set(el, text);  // ‚úÖ FIXED
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     if (uiClasses.some(cls => element.classList.contains(cls))) return true;
        //     if (uiTags.includes(element.tagName.toLowerCase())) return true;
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) return true;
            
        //     return false;
        // }

        // function containsLaoScript(text) {
        //     return /[\u0E80-\u0EFF]/.test(text);
        // }

        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent && !containsLaoScript(node.textContent)) {
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000);
        //     }
        // });

        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });














// language translation is working for domain map, interview data, strong and week signal,ai suggestion with same structure using this

        // async function toggleLanguage() {
        //     if (isTranslating) return;
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
                
        //     } catch (error) {
        //         console.error('Translation error:', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
        //     }
        // }

        // async function translateGeneratedContent() {
        //     const elementsToTranslate = [];
            
        //     // DOMAIN MAP - PRECISE TARGETING
        //     const domainMapContent = document.getElementById('domain-map-content');
        //     if (domainMapContent && domainMapContent.style.display !== 'none') {
                
        //         // 1. Central domain title (the h4 or main title)
        //         const centralTitle = domainMapContent.querySelector('h4, h3, .domain-title');
        //         if (centralTitle && !originalTexts.has(centralTitle)) {
        //             const text = centralTitle.textContent.trim();
        //             if (text && !containsLaoScript(text)) {
        //                 originalTexts.set(centralTitle, text);
        //                 elementsToTranslate.push(centralTitle);
        //             }
        //         }
                
        //         // 2. Central domain description (usually italic/em text)
        //         const italicTexts = domainMapContent.querySelectorAll('em, i');
        //         italicTexts.forEach(el => {
        //             if (!originalTexts.has(el)) {
        //                 const text = el.textContent.trim();
        //                 if (text && text.length > 20 && !containsLaoScript(text)) {
        //                     originalTexts.set(el, text);
        //                     elementsToTranslate.push(el);
        //                 }
        //             }
        //         });
                
        //         // 3. "Sub-domains:" label
        //         const allStrong = domainMapContent.querySelectorAll('strong');
        //         allStrong.forEach(strong => {
        //             const text = strong.textContent.trim();
        //             if (text === 'Sub-domains:' && !originalTexts.has(strong) && !containsLaoScript(text)) {
        //                 originalTexts.set(strong, text);
        //                 elementsToTranslate.push(strong);
        //             }
        //         });
                
        //         // 4. Find all sub-domain cards more precisely
        //         const allDivs = domainMapContent.querySelectorAll('div[style*="border"], div.card, div[class*="border"]');
                
        //         allDivs.forEach(card => {
        //             // Skip if already processed
        //             if (card.dataset.translationProcessed === 'true') return;
        //             card.dataset.translationProcessed = 'true';
                    
        //             // Get all direct children to process them individually
        //             const children = Array.from(card.children);
                    
        //             children.forEach(child => {
        //                 // Sub-domain title (usually first strong or h5)
        //                 if (child.tagName === 'H5' || (child.tagName === 'STRONG' && child.textContent.length < 100)) {
        //                     if (!originalTexts.has(child)) {
        //                         const text = child.textContent.trim();
        //                         if (text && !containsLaoScript(text) && 
        //                             text !== 'Relevance:' && text !== 'Issue Areas:') {
        //                             originalTexts.set(child, text);
        //                             elementsToTranslate.push(child);
        //                         }
        //                     }
        //                 }
                        
        //                 // FIXED: Paragraphs - handle both labels and descriptions
        //                 // Paragraphs - handle ALL paragraphs including descriptions
        //                 if (child.tagName === 'P') {
        //                     const pText = child.textContent.trim();
                            
        //                     // Check for labels like "Relevance:" or "Issue Areas:"
        //                     if (pText.includes('Relevance:') || pText.includes('Issue Areas:')) {
        //                         // Translate the label part
        //                         const labelStrong = child.querySelector('strong');
        //                         if (labelStrong && !originalTexts.has(labelStrong)) {
        //                             const labelText = labelStrong.textContent.trim();
        //                             if (!containsLaoScript(labelText)) {
        //                                 originalTexts.set(labelStrong, labelText);
        //                                 elementsToTranslate.push(labelStrong);
        //                             }
        //                         }
                                
        //                         // Also get the text after the label (the actual content)
        //                         const textAfterLabel = pText.split(':').slice(1).join(':').trim();
        //                         if (textAfterLabel && textAfterLabel.length > 10 && !containsLaoScript(textAfterLabel)) {
        //                             // Store the whole paragraph for translation
        //                             if (!originalTexts.has(child)) {
        //                                 originalTexts.set(child, pText);
        //                                 elementsToTranslate.push(child);
        //                             }
        //                         }
        //                     } else if (pText.length > 10 && !originalTexts.has(child) && !containsLaoScript(pText)) {
        //                         // Regular description paragraph - translate it
        //                         originalTexts.set(child, pText);
        //                         elementsToTranslate.push(child);
        //                     }
        //                 }
                        
        //                 // Lists - get individual items
        //                 if (child.tagName === 'UL' || child.tagName === 'OL') {
        //                     const listItems = child.querySelectorAll('li');
        //                     listItems.forEach(li => {
        //                         if (!originalTexts.has(li)) {
        //                             const text = li.textContent.trim();
        //                             if (text && !containsLaoScript(text)) {
        //                                 originalTexts.set(li, text);
        //                                 elementsToTranslate.push(li);
        //                             }
        //                         }
        //                     });
        //                 }
        //                 // i think it was important
        //                 // added this extra , without adding this it was working by adding that 4 line updates in render domain map function
        //                 // Add after processing list items
        //                 // Process subdomain descriptions specifically
        //                 const subdomainDescriptions = domainMapContent.querySelectorAll('p.subdomain-description');
        //                 subdomainDescriptions.forEach(desc => {
        //                     if (!originalTexts.has(desc)) {
        //                         const text = desc.textContent.trim();
        //                         if (text && !containsLaoScript(text)) {
        //                             originalTexts.set(desc, text);
        //                             elementsToTranslate.push(desc);
        //                         }
        //                     }
        //                 });

        //             });
        //         });
        //     }
            
        //     // OTHER CONTENT AREAS
        //     const otherContentSelectors = [
        //         '#mindmap-content', 
        //         '#interview-analysis-content',
        //         '#signals-strong',
        //         '#signals-weak',
        //         '#signals-ai',
        //         '#steepv-content .matrix-cell',
        //         '#futures-triangle-content .card',
        //         '#futures-triangle-2-content',
        //         '#baseline-scenario-content',
        //         '#driver-outcomes-results',
        //         '#alternative-scenarios-content',
        //         '#wind-tunnel-results',
        //         '#analysis-grid .visioning-analysis-card'
        //     ];

        //     // added this for strong and week signal and ai suggestion for the sources and one more thing was not converted into laos , but without this also it was working by updateing the render strong, week , ai suggestion function
        //     // // SIGNALS SECTIONS - ENHANCED TARGETING
        //     // const signalsSelectors = ['#signals-strong', '#signals-weak', '#signals-ai'];
        //     // signalsSelectors.forEach(selector => {
        //     //     const container = document.querySelector(selector);
        //     //     if (container && container.style.display !== 'none') {
        //     //         // Target all text elements within signal cards
        //     //         const signalCards = container.querySelectorAll('.signal-card');
        //     //         signalCards.forEach(card => {
        //     //             // Get all text-containing elements
        //     //             const textElements = card.querySelectorAll('p, h4, h5, strong, small');
        //     //             textElements.forEach(element => {
        //     //                 if (!originalTexts.has(element)) {
        //     //                     const text = element.textContent.trim();
        //     //                     // Skip empty text and already translated
        //     //                     if (text && text.length > 2 && !containsLaoScript(text)) {
        //     //                         originalTexts.set(element, text);
        //     //                         elementsToTranslate.push(element);
        //     //                     }
        //     //                 }
        //     //             });
                        
        //     //             // CRITICAL: Also check text nodes directly (for Source: XXX, Impact: XXX format)
        //     //             const walker = document.createTreeWalker(
        //     //                 card,
        //     //                 NodeFilter.SHOW_TEXT,
        //     //                 null,
        //     //                 false
        //     //             );
                        
        //     //             let node;
        //     //             while (node = walker.nextNode()) {
        //     //                 const text = node.textContent.trim();
        //     //                 if (text && text.length > 2 && !containsLaoScript(text)) {
        //     //                     // Check if parent is not already in our list
        //     //                     const parent = node.parentElement;
        //     //                     if (parent && !originalTexts.has(parent) && parent.tagName !== 'BUTTON') {
        //     //                         originalTexts.set(parent, parent.textContent.trim());
        //     //                         elementsToTranslate.push(parent);
        //     //                     }
        //     //                 }
        //     //             }
        //     //         });
        //     //     }
        //     // });
            
        //     otherContentSelectors.forEach(selector => {
        //         const containers = document.querySelectorAll(selector);
        //         containers.forEach(container => {
        //             if (container.style.display !== 'none') {
        //                 const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, td');
        //                 htmlElements.forEach(element => {
        //                     if (!originalTexts.has(element)) {
        //                         const text = element.textContent.trim();
        //                         if (text && text.length > 5 && !isUIElement(element) && !containsLaoScript(text)) {
        //                             originalTexts.set(element, text);
        //                             elementsToTranslate.push(element);
        //                         }
        //                     }
        //                 });
        //             }
        //         });
        //     });
            
        //     // Contenteditable areas
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         const text = element.textContent.trim();
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(element) && !containsLaoScript(text)) {
        //             originalTexts.set(element, text);
        //             elementsToTranslate.push(element);
        //         }
        //     });
            
        //     // Mind maps
        //     const mindMapContainer = document.getElementById('mindmap-visualization');
        //     if (mindMapContainer && mindMapContainer.style.display !== 'none') {
        //         const svg = mindMapContainer.querySelector('svg');
        //         if (svg && !originalTexts.has(svg)) {
        //             const textElements = svg.querySelectorAll('text');
        //             textElements.forEach(textEl => {
        //                 const text = textEl.textContent.trim();
        //                 if (text && !originalTexts.has(textEl) && !containsLaoScript(text)) {
        //                     originalTexts.set(textEl, text);
        //                     elementsToTranslate.push(textEl);
        //                 }
        //             });
        //             originalTexts.set(svg, true);
        //         }
        //     }
            
        //     // Translate in batches
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         await translateBatch(batch);
        //     }
        // }

        // async function translateBatch(elements) {
        //     const promises = elements.map(async (element) => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         try {
        //             let textToTranslate = originalContent;
                    
        //             // Ensure it's pure text
        //             if (typeof textToTranslate === 'string') {
        //                 const tempDiv = document.createElement('div');
        //                 tempDiv.innerHTML = textToTranslate;
        //                 textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
        //                 textToTranslate = textToTranslate.trim();
        //             }
                    
        //             if (!textToTranslate || textToTranslate.length < 3) return;
                    
        //             // Skip if contains HTML
        //             if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
        //                 console.warn('Skipping HTML:', textToTranslate.substring(0, 50));
        //                 return;
        //             }
                    
        //             const response = await fetch('/api/translate', {
        //                 method: 'POST',
        //                 headers: { 'Content-Type': 'application/json' },
        //                 body: JSON.stringify({
        //                     text: textToTranslate,
        //                     target_language: 'lo',
        //                     source_language: 'en'
        //                 })
        //             });
                    
        //             const data = await response.json();
                    
        //             if (data.success && data.translated_text) {
        //                 // NEW: Handle text nodes differently
        //                 if (element.nodeType === Node.TEXT_NODE) {
        //                     element.textContent = data.translated_text;
        //                 } else {
        //                     element.textContent = data.translated_text;
        //                 }
        //                 element.dataset.translated = 'true';
        //             }
        //         } catch (error) {
        //             console.error('Translation error:', error);
        //         }
        //     });
            
        //     await Promise.all(promises);
        // }

        // function restoreOriginalTexts() {
        //     originalTexts.forEach((originalContent, element) => {
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') return;
        //         element.textContent = originalContent;
        //         delete element.dataset.translated;
        //     });
            
        //     // Clear processing markers
        //     document.querySelectorAll('[data-translation-processed]').forEach(el => {
        //         delete el.dataset.translationProcessed;
        //     });
        // }

        // // FIXED: translateNewGeneratedContent now uses textContent
        // async function translateNewGeneratedContent(element) {
        //     const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
        //     const elementsToTranslate = [];
            
        //     htmlElements.forEach(el => {
        //         if (!originalTexts.has(el) && !isUIElement(el)) {
        //             const text = el.textContent.trim();  // ‚úÖ FIXED: Use textContent
        //             if (text && text.length > 5 && !containsLaoScript(text)) {
        //                 originalTexts.set(el, text);  // ‚úÖ FIXED: Store text only
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });
            
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         const text = el.textContent.trim();  // ‚úÖ FIXED
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(el) && !containsLaoScript(text)) {
        //             originalTexts.set(el, text);  // ‚úÖ FIXED
        //             elementsToTranslate.push(el);
        //         }
        //     });
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     if (uiClasses.some(cls => element.classList.contains(cls))) return true;
        //     if (uiTags.includes(element.tagName.toLowerCase())) return true;
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) return true;
            
        //     return false;
        // }

        // function containsLaoScript(text) {
        //     return /[\u0E80-\u0EFF]/.test(text);
        // }

        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent && !containsLaoScript(node.textContent)) {
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000);
        //     }
        // });

        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });
















// code for starting again on 09-10-2025 for lao translation
// future triangle 2.0 was fully converted into laos language

        // async function toggleLanguage() {
        //     if (isTranslating) return;
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
                
        //     } catch (error) {
        //         console.error('Translation error:', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
        //     }
        // }

        // async function translateGeneratedContent() {
        //     const elementsToTranslate = [];
            
        //     // DOMAIN MAP - PRECISE TARGETING
        //     const domainMapContent = document.getElementById('domain-map-content');
        //     if (domainMapContent && domainMapContent.style.display !== 'none') {
                
        //         // 1. Central domain title (the h4 or main title)
        //         const centralTitle = domainMapContent.querySelector('h4, h3, .domain-title');
        //         if (centralTitle && !originalTexts.has(centralTitle)) {
        //             const text = centralTitle.textContent.trim();
        //             if (text && !containsLaoScript(text)) {
        //                 originalTexts.set(centralTitle, text);
        //                 elementsToTranslate.push(centralTitle);
        //             }
        //         }
                
        //         // 2. Central domain description (usually italic/em text)
        //         const italicTexts = domainMapContent.querySelectorAll('em, i');
        //         italicTexts.forEach(el => {
        //             if (!originalTexts.has(el)) {
        //                 const text = el.textContent.trim();
        //                 if (text && text.length > 20 && !containsLaoScript(text)) {
        //                     originalTexts.set(el, text);
        //                     elementsToTranslate.push(el);
        //                 }
        //             }
        //         });
                
        //         // 3. "Sub-domains:" label
        //         const allStrong = domainMapContent.querySelectorAll('strong');
        //         allStrong.forEach(strong => {
        //             const text = strong.textContent.trim();
        //             if (text === 'Sub-domains:' && !originalTexts.has(strong) && !containsLaoScript(text)) {
        //                 originalTexts.set(strong, text);
        //                 elementsToTranslate.push(strong);
        //             }
        //         });
                
        //         // 4. Find all sub-domain cards more precisely
        //         const allDivs = domainMapContent.querySelectorAll('div[style*="border"], div.card, div[class*="border"]');
                
        //         allDivs.forEach(card => {
        //             // Skip if already processed
        //             if (card.dataset.translationProcessed === 'true') return;
        //             card.dataset.translationProcessed = 'true';
                    
        //             // Get all direct children to process them individually
        //             const children = Array.from(card.children);
                    
        //             children.forEach(child => {
        //                 // Sub-domain title (usually first strong or h5)
        //                 if (child.tagName === 'H5' || (child.tagName === 'STRONG' && child.textContent.length < 100)) {
        //                     if (!originalTexts.has(child)) {
        //                         const text = child.textContent.trim();
        //                         if (text && !containsLaoScript(text) && 
        //                             text !== 'Relevance:' && text !== 'Issue Areas:') {
        //                             originalTexts.set(child, text);
        //                             elementsToTranslate.push(child);
        //                         }
        //                     }
        //                 }
                        
        //                 // FIXED: Paragraphs - handle both labels and descriptions
        //                 // Paragraphs - handle ALL paragraphs including descriptions
        //                 if (child.tagName === 'P') {
        //                     const pText = child.textContent.trim();
                            
        //                     // Check for labels like "Relevance:" or "Issue Areas:"
        //                     if (pText.includes('Relevance:') || pText.includes('Issue Areas:')) {
        //                         // Translate the label part
        //                         const labelStrong = child.querySelector('strong');
        //                         if (labelStrong && !originalTexts.has(labelStrong)) {
        //                             const labelText = labelStrong.textContent.trim();
        //                             if (!containsLaoScript(labelText)) {
        //                                 originalTexts.set(labelStrong, labelText);
        //                                 elementsToTranslate.push(labelStrong);
        //                             }
        //                         }
                                
        //                         // Also get the text after the label (the actual content)
        //                         const textAfterLabel = pText.split(':').slice(1).join(':').trim();
        //                         if (textAfterLabel && textAfterLabel.length > 10 && !containsLaoScript(textAfterLabel)) {
        //                             // Store the whole paragraph for translation
        //                             if (!originalTexts.has(child)) {
        //                                 originalTexts.set(child, pText);
        //                                 elementsToTranslate.push(child);
        //                             }
        //                         }
        //                     } else if (pText.length > 10 && !originalTexts.has(child) && !containsLaoScript(pText)) {
        //                         // Regular description paragraph - translate it
        //                         originalTexts.set(child, pText);
        //                         elementsToTranslate.push(child);
        //                     }
        //                 }
                        
        //                 // Lists - get individual items
        //                 if (child.tagName === 'UL' || child.tagName === 'OL') {
        //                     const listItems = child.querySelectorAll('li');
        //                     listItems.forEach(li => {
        //                         if (!originalTexts.has(li)) {
        //                             const text = li.textContent.trim();
        //                             if (text && !containsLaoScript(text)) {
        //                                 originalTexts.set(li, text);
        //                                 elementsToTranslate.push(li);
        //                             }
        //                         }
        //                     });
        //                 }
        //                 // i think it was important
        //                 // added this extra , without adding this it was working by adding that 4 line updates in render domain map function
        //                 // Add after processing list items
        //                 // Process subdomain descriptions specifically
        //                 const subdomainDescriptions = domainMapContent.querySelectorAll('p.subdomain-description');
        //                 subdomainDescriptions.forEach(desc => {
        //                     if (!originalTexts.has(desc)) {
        //                         const text = desc.textContent.trim();
        //                         if (text && !containsLaoScript(text)) {
        //                             originalTexts.set(desc, text);
        //                             elementsToTranslate.push(desc);
        //                         }
        //                     }
        //                 });

        //             });
        //         });
        //     }
            
        //     // OTHER CONTENT AREAS
        //     const otherContentSelectors = [
        //         '#mindmap-content', 
        //         '#interview-analysis-content',
        //         '#signals-strong',
        //         '#signals-weak',
        //         '#signals-ai',
        //         '#steepv-content .matrix-cell',
        //         '#futures-triangle-content .card',
        //         '#futures-triangle-2-content',
        //         '#baseline-scenario-content',
        //         '#driver-outcomes-results',
        //         '#alternative-scenarios-content',
        //         '#wind-tunnel-results',
        //         '#analysis-grid .visioning-analysis-card'
        //     ];
           
        //     otherContentSelectors.forEach(selector => {
        //         const containers = document.querySelectorAll(selector);
        //         containers.forEach(container => {
        //             if (container.style.display !== 'none') {
        //                 const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, td');
        //                 htmlElements.forEach(element => {
        //                     if (!originalTexts.has(element)) {
        //                         const text = element.textContent.trim();
        //                         if (text && text.length > 5 && !isUIElement(element) && !containsLaoScript(text)) {
        //                             originalTexts.set(element, text);
        //                             elementsToTranslate.push(element);
        //                         }
        //                     }
        //                 });
        //             }
        //         });
        //     });
            
        //     // Contenteditable areas
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         const text = element.textContent.trim();
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(element) && !containsLaoScript(text)) {
        //             originalTexts.set(element, text);
        //             elementsToTranslate.push(element);
        //         }
        //     });
            
        //     // Mind maps
        //     const mindMapContainer = document.getElementById('mindmap-visualization');
        //     if (mindMapContainer && mindMapContainer.style.display !== 'none') {
        //         const svg = mindMapContainer.querySelector('svg');
        //         if (svg && !originalTexts.has(svg)) {
        //             const textElements = svg.querySelectorAll('text');
        //             textElements.forEach(textEl => {
        //                 const text = textEl.textContent.trim();
        //                 if (text && !originalTexts.has(textEl) && !containsLaoScript(text)) {
        //                     originalTexts.set(textEl, text);
        //                     elementsToTranslate.push(textEl);
        //                 }
        //             });
        //             originalTexts.set(svg, true);
        //         }
        //     }


            
        //     // Translate in batches
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         await translateBatch(batch);
        //     }

        //     // this also working for future triangle 2.0 
        //     // PHASE 3: Handle newly generated content that may need translation
        //     const phase3Container = document.getElementById('futures-triangle-2-content');
        //     if (phase3Container && phase3Container.style.display !== 'none') {
        //         await translateNewGeneratedContent(phase3Container);
        //     }
        // }

        // async function translateBatch(elements) {
        //     const promises = elements.map(async (element) => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         try {
        //             let textToTranslate = originalContent;
                    
        //             // Ensure it's pure text
        //             if (typeof textToTranslate === 'string') {
        //                 const tempDiv = document.createElement('div');
        //                 tempDiv.innerHTML = textToTranslate;
        //                 textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
        //                 textToTranslate = textToTranslate.trim();
        //             }
                    
        //             if (!textToTranslate || textToTranslate.length < 3) return;
                    
        //             // Skip if contains HTML
        //             if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
        //                 console.warn('Skipping HTML:', textToTranslate.substring(0, 50));
        //                 return;
        //             }
                    
        //             const response = await fetch('/api/translate', {
        //                 method: 'POST',
        //                 headers: { 'Content-Type': 'application/json' },
        //                 body: JSON.stringify({
        //                     text: textToTranslate,
        //                     target_language: 'lo',
        //                     source_language: 'en'
        //                 })
        //             });
                    
        //             const data = await response.json();
                    
        //             if (data.success && data.translated_text) {
        //                 // NEW: Handle text nodes differently
        //                 if (element.nodeType === Node.TEXT_NODE) {
        //                     element.textContent = data.translated_text;
        //                 } else {
        //                     element.textContent = data.translated_text;
        //                 }
        //                 element.dataset.translated = 'true';
        //             }
        //         } catch (error) {
        //             console.error('Translation error:', error);
        //         }
        //     });
            
        //     await Promise.all(promises);
        // }

        // function restoreOriginalTexts() {
        //     originalTexts.forEach((originalContent, element) => {
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') return;
        //         element.textContent = originalContent;
        //         delete element.dataset.translated;
        //     });
            
        //     // Clear processing markers
        //     document.querySelectorAll('[data-translation-processed]').forEach(el => {
        //         delete el.dataset.translationProcessed;
        //     });
        // }

        // // FIXED: translateNewGeneratedContent now uses textContent
        // // async function translateNewGeneratedContent(element) {
        // //     const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
        // //     const elementsToTranslate = [];
            
        // //     htmlElements.forEach(el => {
        // //         if (!originalTexts.has(el) && !isUIElement(el)) {
        // //             const text = el.textContent.trim();  // ‚úÖ FIXED: Use textContent
        // //             if (text && text.length > 5 && !containsLaoScript(text)) {
        // //                 originalTexts.set(el, text);  // ‚úÖ FIXED: Store text only
        // //                 elementsToTranslate.push(el);
        // //             }
        // //         }
        // //     });
            
        // //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        // //     editableElements.forEach(el => {
        // //         const text = el.textContent.trim();  // ‚úÖ FIXED
        // //         if (text && text.length > 5 && !text.includes('Click to add') && 
        // //             !originalTexts.has(el) && !containsLaoScript(text)) {
        // //             originalTexts.set(el, text);  // ‚úÖ FIXED
        // //             elementsToTranslate.push(el);
        // //         }
        // //     });

        // //     // ADD THIS SECTION TO YOUR translateNewGeneratedContent FUNCTION
        // //     // After the existing contenteditable loop, add this specific handler for Phase 3

        // //     // PHASE 3 SPECIFIC: Futures Triangle 2.0 Additional Elements
        // //     const phase3Selectors = [
        // //         '#drivers-content [style*="margin-bottom"]',
        // //         '#uncertainties-content [style*="margin-bottom"]',
        // //         '#narratives-content [style*="margin-bottom"]'
        // //     ];

        // //     phase3Selectors.forEach(selector => {
        // //         const containers = document.querySelectorAll(selector);
        // //         containers.forEach(container => {
        // //             if (container.style.display !== 'none') {
        // //                 // Get all span and small elements within each driver/uncertainty/narrative card
        // //                 const allTextElements = container.querySelectorAll('strong, span:not([style*="margin"]), small');
                        
        // //                 allTextElements.forEach(element => {
        // //                     if (!originalTexts.has(element)) {
        // //                         const text = element.textContent.trim();
                                
        // //                         // Only translate meaningful content, skip labels like "Category:", "Impact:", etc.
        // //                         if (text && text.length > 3 && 
        // //                             !text.endsWith(':') && 
        // //                             !isUILabel(text) && 
        // //                             !containsLaoScript(text)) {
                                    
        // //                             originalTexts.set(element, text);
        // //                             elementsToTranslate.push(element);
        // //                         }
        // //                     }
        // //                 });
        // //             }
        // //         });
        // //     });


        // //     // Add this after the existing phase3Selectors loop above

        // //     // Target specifically marked translatable elements
        // //     const translatableElements = element.querySelectorAll('.translatable');
        // //     translatableElements.forEach(el => {
        // //         if (!originalTexts.has(el) && !isUILabel(el.textContent)) {
        // //             const text = el.textContent.trim();
        // //             if (text && text.length > 3 && !containsLaoScript(text)) {
        // //                 originalTexts.set(el, text);
        // //                 elementsToTranslate.push(el);
        // //             }
        // //         }
        // //     });
                        
        // //     if (elementsToTranslate.length > 0) {
        // //         await translateBatch(elementsToTranslate);
        // //     }
        // // }



        // async function translateNewGeneratedContent(element) {
        //     // CRITICAL: Skip if element already has translated content
        //     if (element && element.dataset?.translated === 'true') {
        //         console.log('Skipping already translated element');
        //         return;
        //     }

        //     const elementsToTranslate = [];
            
        //     // Skip if already contains Lao script
        //     if (element && containsLaoScript(element.textContent)) {
        //         return;
        //     }

        //     const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
            
        //     htmlElements.forEach(el => {
        //         // Triple check: don't translate if already Lao
        //         if (containsLaoScript(el.textContent)) {
        //             return;
        //         }

        //         if (!originalTexts.has(el) && !isUIElement(el)) {
        //             const text = el.textContent.trim();
        //             if (text && text.length > 5) {
        //                 originalTexts.set(el, text);
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });
            
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         if (containsLaoScript(el.textContent)) {
        //             return;
        //         }

        //         const text = el.textContent.trim();
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(el)) {
        //             originalTexts.set(el, text);
        //             elementsToTranslate.push(el);
        //         }
        //     });

        //     // PHASE 3 SPECIFIC: ONLY use .translatable elements
        //     // Don't use phase3Selectors - rely ONLY on the .translatable class to avoid double translation
            
        //     const translatableElements = element.querySelectorAll('.translatable');
        //     translatableElements.forEach(el => {
        //         // Skip if already Lao
        //         if (containsLaoScript(el.textContent)) {
        //             return;
        //         }

        //         if (!originalTexts.has(el) && !isUILabel(el.textContent)) {
        //             const text = el.textContent.trim();
        //             if (text && text.length > 3) {
        //                 originalTexts.set(el, text);
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });

        //     // Mark container as translated BEFORE translation starts
        //     if (element) {
        //         element.dataset.translated = 'true';
        //     }
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // // ============================================
        // // ADD THIS HELPER FUNCTION
        // // ============================================
        // function isUILabel(text) {
        //     const labels = [
        //         'Impact', 'Certainty', 'Category', 'Trajectory', 'Possible outcomes', 
        //         'Influence', 'Type', 'Outcomes possible', 'Category:', 'Trajectory:', 
        //         'Possible outcomes:', 'Influence areas:', 'Type:', 'Resolution:', 
        //         'Impact Impact', 'Certainty', 'Current trajectory'
        //     ];
        //     return labels.some(label => text.includes(label));
        // }

        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     if (uiClasses.some(cls => element.classList.contains(cls))) return true;
        //     if (uiTags.includes(element.tagName.toLowerCase())) return true;
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) return true;
            
        //     return false;
        // }

        // function containsLaoScript(text) {
        //     return /[\u0E80-\u0EFF]/.test(text);
        // }

        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent && !containsLaoScript(node.textContent)) {
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000);
        //     }
        // });

        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });


















// 09-10-2025
// want to start for baseline scenario in phase 3 for lao translation--it was completed but no changes in this code
// updated the renderBaselineScenario function only for baseline scenario in laos language
// this is same code only of the above code
// 10-10-2025
// updated the renderDriverOutcomes function for laos translation for driver outcome in phase 3-no changes in this below code
// updated the renderAlternativeScenarios and formatScenarioText function for laos translation for alternative scenario in phase 3- no changes in this below code- after changing this two function also the output is look like the same as before
// in this newly renderAlternativeScenarios and formatScenarioText function there was a problem , some text generating two time, so we can go with old one itself--i was removed the newly added code
// this is same code only of the above code

// 13-10-2025
// monday start with phase 2 remaining lao language translation or solve the multiple times laos was converting problem

// 13-10-2025
// updated this code to solve the duplicate and multiple time translation for phase 1,3,4. in phase 2 strong and week signal and ai suggestion
// updated to check multiple api calls
        // async function toggleLanguage() {
        //     if (isTranslating) {
        //         console.log(`[LANG] Translation already in progress, skipping`);
        //         return;
        //     }
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     console.log(`\n[LANG TOGGLE] Starting: ${currentLanguage} ‚Üí ${targetLanguage}`);
        //     console.log(`[LANG TOGGLE] Cache: ${translationCache.size} entries, Pending: ${pendingTranslations.size}\n`);
            
        //     // Clear any pending translations
        //     pendingTranslations.clear();
            
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             console.log(`[LANG] Initiating EN‚ÜíLO translation`);
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             console.log(`[LANG] Restoring original English text`);
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
        //         console.log(`[LANG TOGGLE] Completed successfully\n`);
                
        //     } catch (error) {
        //         console.error('[LANG ERROR]', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
                
        //         // Final cleanup
        //         pendingTranslations.clear();
        //     }
        // }



        // // updated to check multiple api calls
        // async function translateGeneratedContent() {
        //     console.log(`\n${'='.repeat(60)}`);
        //     console.log(`[TRANSLATE CONTENT] Starting full content translation`);
        //     console.log(`[TRANSLATE CONTENT] Current phase: ${currentPhase}`);
        //     console.log(`${'='.repeat(60)}\n`);
            
        //     const elementsToTranslate = [];
        //     let totalCollected = 0;

        //     // Define containers to process
        //     const containersToProcess = [
        //         { id: 'domain-map-content', name: 'domain-map' },
        //         { id: 'mindmap-visualization', name: 'mind-map', isSVG: true },
        //         { id: 'interview-analysis-content', name: 'interview-analysis' },
        //         { id: 'signals-strong', name: 'signals-strong' },
        //         { id: 'signals-weak', name: 'signals-weak' },
        //         { id: 'signals-ai', name: 'signals-ai' },
        //         { id: 'steepv-content', name: 'steepv' },
        //         { id: 'futures-triangle-content', name: 'futures-triangle' },
        //         { id: 'futures-triangle-2-content', name: 'futures-triangle-2' },
        //         { id: 'baseline-scenario-content', name: 'baseline-scenario' },
        //         { id: 'driver-outcomes-results', name: 'driver-outcomes' },
        //         { id: 'alternative-scenarios-content', name: 'alt-scenarios' },
        //         { id: 'wind-tunnel-results', name: 'wind-tunnel' }
        //     ];

        //     // Process each container
        //     for (const containerDef of containersToProcess) {
        //         const container = document.getElementById(containerDef.id);
                
        //         if (!container || container.style.display === 'none') {
        //             continue;
        //         }

        //         console.log(`[PHASE-CHECK] Processing ${containerDef.name}`);

        //         if (containerDef.isSVG) {
        //             // Handle SVG elements specially
        //             const svg = container.querySelector('svg');
        //             if (svg) {
        //                 const textElements = svg.querySelectorAll('text');
        //                 textElements.forEach(textEl => {
        //                     if (!originalTexts.has(textEl)) {
        //                         const text = textEl.textContent.trim();
        //                         if (text && !containsLaoScript(text)) {
        //                             originalTexts.set(textEl, text);
        //                             elementsToTranslate.push(textEl);
        //                             totalCollected++;
        //                         }
        //                     }
        //                 });
        //             }
        //         } else {
        //             // Handle regular HTML elements
        //             const elementsInPhase = collectElementsFromContainer(container, containerDef.name);
        //             elementsToTranslate.push(...elementsInPhase);
        //             totalCollected += elementsInPhase.length;
        //         }
        //     }

        //     // Also handle contenteditable elements
        //     console.log(`[PHASE-CHECK] Processing contenteditable elements`);
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         if (element.style.display === 'none') return;
                
        //         const text = element.textContent.trim();
        //         const normalizedText = normalizeText(text);
                
        //         if (text && 
        //             text.length >= 10 &&
        //             !text.includes('Click to add') && 
        //             !originalTexts.has(element) && 
        //             !containsLaoScript(text) &&
        //             !uniqueTranslationTexts.has(normalizedText)) {
                    
        //             originalTexts.set(element, text);
        //             uniqueTranslationTexts.add(normalizedText);
        //             elementsToTranslate.push(element);
        //             totalCollected++;
        //         }
        //     });

        //     console.log(`\n[SUMMARY] Total elements collected: ${totalCollected}`);
        //     console.log(`[SUMMARY] Starting batch translation with batch size 10\n`);

        //     // Batch translate with larger batch size
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         const batchNum = Math.floor(i / batchSize) + 1;
        //         const totalBatches = Math.ceil(elementsToTranslate.length / batchSize);
                
        //         console.log(`[BATCH] ${batchNum}/${totalBatches} - Processing ${batch.length} elements`);
        //         await translateBatch(batch);
                
        //         // Small delay between batches
        //         await new Promise(resolve => setTimeout(resolve, 200));
        //     }

        //     console.log(`\n[COMPLETE] Translation of all content finished\n`);
        // }


        // // newly added to check multiple api calls
        // // ADD THIS NEW HELPER FUNCTION:
        // function collectElementsFromContainer(container, containerName) {
        //     console.log(`  [COLLECT] Scanning: ${containerName}`);
        //     const elements = [];
        //     let skipped = 0;
        //     let collected = 0;

        //     const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, strong, em, span, div');

        //     htmlElements.forEach(element => {
        //         // SKIP 0: Elements marked to skip translation
        //         if (element.classList.contains('skip-translation')) {
        //             return;
        //         }
                
        //         // SKIP 1: Already processed
        //         if (element.dataset.translationProcessed === 'true') {
        //             skipped++;
        //             return;
        //         }

        //         // SKIP 2: Already has Lao script
        //         if (containsLaoScript(element.textContent)) {
        //             skipped++;
        //             return;
        //         }

        //         // SKIP 3: Already tracked in originalTexts
        //         if (originalTexts.has(element)) {
        //             skipped++;
        //             return;
        //         }

        //         const text = element.textContent.trim();

        //         // SKIP 4: Text is too short (min 20 chars to avoid labels)
        //         if (!text || text.length < 20) {
        //             return;
        //         }

        //         // SKIP 5: UI elements or buttons
        //         if (isUIElement(element)) {
        //             return;
        //         }

        //         // SKIP 6: UI labels
        //         if (isUILabel(text)) {
        //             return;
        //         }

        //         // SKIP 7: Contains HTML
        //         if (text.includes('<') || text.includes('>')) {
        //             return;
        //         }

        //         // SKIP 8: Only emoji/bullets
        //         if (text.match(/^[‚ñ∂‚ö°üéØüìäüîç‚ö†Ô∏è‚öôÔ∏èüí™üîÑüìÑüí°üé§üîçüíæ‚úÖ‚ùå]/)) {
        //             return;
        //         }

        //         // SKIP 9: Duplicate check - don't translate same text twice (normalized)
        //         const normalizedText = normalizeText(text);
        //         if (uniqueTranslationTexts.has(normalizedText)) {
        //             console.log(`    [SKIP-DUP] Already scheduled: "${text.substring(0, 30)}..."`);
        //             skipped++;
        //             return;
        //         }
                
        //         // SKIP 10: Check if already in cache
        //         const cacheKey = `${normalizedText}_lo`;
        //         if (translationCache.has(cacheKey)) {
        //             console.log(`    [SKIP-CACHE] In cache: "${text.substring(0, 30)}..."`);
        //             // Apply cached translation immediately
        //             element.textContent = translationCache.get(cacheKey);
        //             element.dataset.translated = 'true';
        //             element.dataset.translationProcessed = 'true';
        //             skipped++;
        //             return;
        //         }

        //         // If we got here, add it for translation
        //         originalTexts.set(element, text);
        //         uniqueTranslationTexts.add(normalizedText); // Mark as scheduled with normalized text
        //         element.dataset.translationProcessed = 'true';
        //         elements.push(element);
        //         collected++;
        //     });

        //     console.log(`  [COLLECT] Collected: ${collected}, Skipped: ${skipped}`);
        //     return elements;
        // }



        // // updated to check multiple api calls
        // async function translateBatch(elements) {
        //     console.log(`  [BATCH] Processing ${elements.length} elements`);
            
        //     // STEP 1: Group elements by their text content
        //     const textToElements = new Map();
            
        //     elements.forEach(element => {
        //         const originalContent = originalTexts.get(element);
        //         if (!originalContent) return;
                
        //         // Use normalized text as key to group identical texts
        //         const normalizedText = normalizeText(originalContent);
                
        //         if (!textToElements.has(normalizedText)) {
        //             textToElements.set(normalizedText, []);
        //         }
        //         textToElements.get(normalizedText).push(element);
        //     });
            
        //     console.log(`  [BATCH] Deduplicated: ${elements.length} elements ‚Üí ${textToElements.size} unique texts`);
            
        //     // STEP 2: Process each unique text only once
        //     const promises = Array.from(textToElements.entries()).map(async ([normalizedText, elementGroup], index) => {
        //         const firstElement = elementGroup[0];
        //         const originalContent = originalTexts.get(firstElement);
                
        //         if (!originalContent) {
        //             console.log(`    [SKIP-${index}] No original content`);
        //             return;
        //         }

        //         // Skip if already contains Lao
        //         if (containsLaoScript(originalContent)) {
        //             console.log(`    [SKIP-${index}] Already Lao`);
        //             return;
        //         }

        //         // Check if already marked as translated
        //         if (firstElement.dataset?.translated === 'true') {
        //             console.log(`    [SKIP-${index}] Already marked as translated`);
        //             return;
        //         }

        //         try {
        //             let textToTranslate = originalContent;

        //             // Clean the text
        //             if (typeof textToTranslate === 'string') {
        //                 const tempDiv = document.createElement('div');
        //                 tempDiv.innerHTML = textToTranslate;
        //                 textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
        //                 textToTranslate = textToTranslate.trim();
        //             }

        //             // Validation
        //             if (!textToTranslate || textToTranslate.length < 10) {
        //                 console.log(`    [SKIP-${index}] Text too short`);
        //                 return;
        //             }

        //             if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
        //                 console.log(`    [SKIP-${index}] Contains HTML`);
        //                 return;
        //             }

        //             if (containsLaoScript(textToTranslate)) {
        //                 console.log(`    [SKIP-${index}] Text is already Lao`);
        //                 return;
        //             }

        //             // Check cache first
        //             const cacheKey = `${normalizedText}_lo`;
                    
        //             if (translationCache.has(cacheKey)) {
        //                 const cachedText = translationCache.get(cacheKey);
        //                 console.log(`    [CACHE-${index}] Hit for ${elementGroup.length} element(s): "${textToTranslate.substring(0, 35)}..."`);
                        
        //                 // Apply cached translation to ALL elements with same text
        //                 elementGroup.forEach(el => {
        //                     el.textContent = cachedText;
        //                     el.dataset.translated = 'true';
        //                 });
        //                 return;
        //             }

        //             // CRITICAL: Check if this text is already being translated
        //             if (pendingTranslations.has(normalizedText)) {
        //                 console.log(`    [WAIT-${index}] Translation already in progress for ${elementGroup.length} element(s), waiting...`);
                        
        //                 try {
        //                     // Wait for the existing translation to complete
        //                     const translatedText = await pendingTranslations.get(normalizedText);
                            
        //                     // Apply the result to all elements
        //                     elementGroup.forEach(el => {
        //                         el.textContent = translatedText;
        //                         el.dataset.translated = 'true';
        //                     });
                            
        //                     console.log(`    [WAIT-${index}] ‚úì Applied result from pending translation`);
        //                 } catch (error) {
        //                     console.error(`    [WAIT-${index}] ‚ùå Pending translation failed:`, error.message);
        //                 }
                        
        //                 return;
        //             }

        //             console.log(`    [API-${index}] NEW translation for ${elementGroup.length} element(s) (${textToTranslate.length}ch): "${textToTranslate.substring(0, 40)}..."`);

        //             // Create the translation promise
        //             const translationPromise = (async () => {
        //                 const response = await fetch('/api/translate', {
        //                     method: 'POST',
        //                     headers: { 'Content-Type': 'application/json' },
        //                     body: JSON.stringify({
        //                         text: textToTranslate,
        //                         target_language: 'lo',
        //                         source_language: 'en'
        //                     })
        //                 });

        //                 const data = await response.json();

        //                 if (!data.success || !data.translated_text) {
        //                     throw new Error(data.error || 'Translation failed');
        //                 }

        //                 return data.translated_text;
        //             })();

        //             // Store the promise IMMEDIATELY to prevent duplicate calls
        //             pendingTranslations.set(normalizedText, translationPromise);

        //             try {
        //                 // Await the translation
        //                 const translatedText = await translationPromise;
                        
        //                 console.log(`    [SUCCESS-${index}] ‚úì Translated for ${elementGroup.length} element(s): "${translatedText.substring(0, 40)}..."`);
                        
        //                 // Apply to ALL elements with the same text
        //                 elementGroup.forEach(el => {
        //                     el.textContent = translatedText;
        //                     el.dataset.translated = 'true';
        //                 });
                        
        //                 // Store in cache
        //                 translationCache.set(cacheKey, translatedText);
                        
        //             } catch (error) {
        //                 console.error(`    [ERROR-${index}] Translation failed:`, error.message);
        //             } finally {
        //                 // Clean up: Remove from pending map
        //                 pendingTranslations.delete(normalizedText);
        //             }

        //         } catch (error) {
        //             console.error(`    [EXCEPTION-${index}]`, error.message);
        //             // Make sure to clean up pending map
        //             pendingTranslations.delete(normalizedText);
        //         }
        //     });

        //     await Promise.all(promises);
            
        //     console.log(`  [BATCH] Completed. Pending translations: ${pendingTranslations.size}`);
        // }



        // // DEBUG: Add a function to check current state
        // function debugTranslationState() {
        //     console.log('=== TRANSLATION STATE DEBUG ===');
        //     console.log('Current Language:', currentLanguage);
        //     console.log('Is Translating:', isTranslating);
        //     console.log('Original Texts Count:', originalTexts.size);
        //     console.log('Translation Cache Count:', translationCache.size);
        //     console.log('Unique Translation Texts:', uniqueTranslationTexts.size);
            
        //     // Check for any Lao content in the page
        //     const allText = document.body.textContent;
        //     const hasLao = containsLaoScript(allText);
        //     console.log('Page contains Lao script:', hasLao);
            
        //     // Check translated elements
        //     const translatedElements = document.querySelectorAll('[data-translated="true"]');
        //     console.log('Elements marked as translated:', translatedElements.length);
            
        //     // Check elements with Lao content
        //     let laoElementCount = 0;
        //     document.querySelectorAll('*').forEach(el => {
        //         if (containsLaoScript(el.textContent)) {
        //             laoElementCount++;
        //         }
        //     });
        //     console.log('Elements with Lao content:', laoElementCount);
        //     console.log('===============================');
        // }

        // // DEBUG: Show deduplication stats
        // // DEBUG: Show deduplication stats
        // function debugDeduplication() {
        //     console.log('=== DEDUPLICATION DEBUG ===');
        //     console.log('Original Texts Map:', originalTexts.size);
        //     console.log('Translation Cache:', translationCache.size);
        //     console.log('Pending Translations:', pendingTranslations.size);
        //     console.log('Unique Translation Texts:', uniqueTranslationTexts.size);
            
        //     // Show what's currently pending
        //     if (pendingTranslations.size > 0) {
        //         console.log('\nCurrently pending:');
        //         Array.from(pendingTranslations.keys()).forEach((key, i) => {
        //             console.log(`  ${i + 1}. "${key.substring(0, 50)}..."`);
        //         });
        //     }
            
        //     // Check for duplicate texts in originalTexts
        //     const textCounts = new Map();
        //     originalTexts.forEach((text, element) => {
        //         const normalized = normalizeText(text);
        //         textCounts.set(normalized, (textCounts.get(normalized) || 0) + 1);
        //     });
            
        //     const duplicates = Array.from(textCounts.entries()).filter(([text, count]) => count > 1);
        //     if (duplicates.length > 0) {
        //         console.log(`\nFound ${duplicates.length} duplicate texts:`);
        //         duplicates.forEach(([text, count]) => {
        //             console.log(`  "${text.substring(0, 40)}..." appears ${count} times`);
        //         });
        //     } else {
        //         console.log('\nNo duplicate texts found in originalTexts map');
        //     }
            
        //     console.log('===========================');
        // }

        // // Call after translation: debugDeduplication()

        // // Call after translation: debugDeduplication()
        // // Call after translation: debugDeduplication()

        // // Call this function in console to debug: debugTranslationState()

        // // updated to check multiple api calls
        // function restoreOriginalTexts() {
        //     console.log(`[RESTORE] Starting restoration of original English text`);
            
        //     // Clear pending translations
        //     pendingTranslations.clear();
            
        //     let restored = 0;
        //     let skipped = 0;

        //     originalTexts.forEach((originalContent, element) => {
        //         // Skip SVG elements and non-string content
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') {
        //             skipped++;
        //             return;
        //         }

        //         try {
        //             element.textContent = originalContent;
        //             delete element.dataset.translated;
        //             delete element.dataset.translationProcessed;
        //             restored++;
        //         } catch (error) {
        //             console.error(`[RESTORE ERROR]`, error);
        //             skipped++;
        //         }
        //     });

        //     console.log(`[RESTORE] Completed - Restored: ${restored}, Skipped: ${skipped}`);
            
        //     // Clear caches when going back to English
        //     uniqueTranslationTexts.clear();
        //     console.log(`[RESTORE] Cleared translation cache for next translation cycle`);
        // }


        // async function translateNewGeneratedContent(element) {
        //     console.log('[TRANSLATE NEW] Starting translation check for new content');
            
        //     // CRITICAL: Skip if element already has Lao content anywhere
        //     if (hasAnyLaoContent(element)) {
        //         console.log('[TRANSLATE NEW] Skipping - element already contains Lao text');
        //         return;
        //     }

        //     // CRITICAL: Skip if already marked as translated
        //     if (element && element.dataset?.translated === 'true') {
        //         console.log('[TRANSLATE NEW] Skipping - element already marked as translated');
        //         return;
        //     }

        //     const elementsToTranslate = [];
            
        //     const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
            
        //     htmlElements.forEach(el => {
        //         // Skip if this specific element contains Lao
        //         if (containsLaoScript(el.textContent)) {
        //             console.log('[TRANSLATE NEW] Skipping element - already has Lao:', el.textContent.substring(0, 30));
        //             return;
        //         }

        //         // Skip if already translated
        //         if (el.dataset?.translated === 'true') {
        //             return;
        //         }

        //         // Skip if already in originalTexts (being processed)
        //         if (originalTexts.has(el)) {
        //             return;
        //         }

        //         if (!isUIElement(el)) {
        //             const text = el.textContent.trim();
        //             if (text && text.length > 5) {
        //                 originalTexts.set(el, text);
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });
            
        //     const editableElements = element.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(el => {
        //         if (containsLaoScript(el.textContent)) {
        //             return;
        //         }

        //         if (el.dataset?.translated === 'true') {
        //             return;
        //         }

        //         const text = el.textContent.trim();
        //         if (text && text.length > 5 && !text.includes('Click to add') && 
        //             !originalTexts.has(el)) {
        //             originalTexts.set(el, text);
        //             elementsToTranslate.push(el);
        //         }
        //     });

        //     const translatableElements = element.querySelectorAll('.translatable');
        //     translatableElements.forEach(el => {
        //         if (containsLaoScript(el.textContent)) {
        //             return;
        //         }

        //         if (el.dataset?.translated === 'true') {
        //             return;
        //         }

        //         if (!originalTexts.has(el) && !isUILabel(el.textContent)) {
        //             const text = el.textContent.trim();
        //             if (text && text.length > 3) {
        //                 originalTexts.set(el, text);
        //                 elementsToTranslate.push(el);
        //             }
        //         }
        //     });

        //     // Mark container as translated BEFORE starting translation
        //     if (element) {
        //         element.dataset.translated = 'true';
        //     }
            
        //     console.log(`[TRANSLATE NEW] Found ${elementsToTranslate.length} elements to translate`);
            
        //     if (elementsToTranslate.length > 0) {
        //         await translateBatch(elementsToTranslate);
        //     }
        // }

        // function isUILabel(text) {
        //     const labels = [
        //         'Impact', 'Certainty', 'Category', 'Trajectory', 'Possible outcomes', 
        //         'Influence', 'Type', 'Outcomes possible', 'Category:', 'Trajectory:', 
        //         'Possible outcomes:', 'Influence areas:', 'Type:', 'Resolution:', 
        //         'Impact Impact', 'Current trajectory', 'Source:', 'Potential:', 'Relevance:',
        //         'Issue Areas:', 'Strong', 'Weak', 'Medium', 'High', 'Low', 'Rationale:',
        //         // Technical terms that should not be translated
        //         'Collapse/Decline', 'New Equilibrium', 'Transformation', 
        //         'Key Factors', 'Critical Assumptions', 'Early Warning Indicators',
        //         'VIABILITY', 'PROCESS', 'CAPABILITIES', 'ADAPTATIONS NEEDED',
        //         'Collapse', 'Decline', 'Equilibrium', 'Story Shift', 'Key Variables',
        //         'Dominant Drivers', 'Timeframe'
        //     ];
        //     return labels.some(label => text.includes(label));
        // }

        // function isUIElement(element) {
        //     const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
        //     const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
        //     if (uiClasses.some(cls => element.classList.contains(cls))) return true;
        //     if (uiTags.includes(element.tagName.toLowerCase())) return true;
        //     if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) return true;
            
        //     return false;
        // }


        // // updated to check multiple api calls
        // // Normalize text for better caching
        // function normalizeText(text) {
        //     if (!text) return '';
        //     return text.trim().replace(/\s+/g, ' ').toLowerCase();
        // }

        // function hasAnyLaoContent(element) {
        //     if (!element) return false;
            
        //     // Check the element's own text
        //     if (containsLaoScript(element.textContent)) {
        //         return true;
        //     }
            
        //     // Check if element has been marked as translated
        //     if (element.dataset?.translated === 'true') {
        //         return true;
        //     }
            
        //     // Check if any child has Lao content
        //     const allText = element.querySelectorAll('*');
        //     for (let el of allText) {
        //         if (containsLaoScript(el.textContent) || el.dataset?.translated === 'true') {
        //             return true;
        //         }
        //     }
            
        //     return false;
        // }


        // function containsLaoScript(text) {
        //     if (!text) return false;
        //     return /[\u0E80-\u0EFF]/.test(text);
        // }

        // function isAlreadyTranslated(element) {
        //     if (!element) return false;
        //     const text = element.textContent || element.innerText || '';
        //     return containsLaoScript(text);
        // }

        // const observer = new MutationObserver((mutations) => {
        //     if (currentLanguage === 'lo' && !isTranslating) {
        //         clearTimeout(translationTimeout);
        //         translationTimeout = setTimeout(() => {
        //             mutations.forEach((mutation) => {
        //                 if (mutation.type === 'childList') {
        //                     mutation.addedNodes.forEach((node) => {
        //                         if (node.nodeType === Node.ELEMENT_NODE) {
        //                             // IMPROVED: Skip if node already contains Lao
        //                             if (hasAnyLaoContent(node)) {
        //                                 console.log('[OBSERVER] Skipping node - already has Lao content');
        //                                 return;
        //                             }

        //                             // IMPROVED: Skip if node is marked as translated
        //                             if (node.dataset?.translated === 'true') {
        //                                 console.log('[OBSERVER] Skipping node - already marked translated');
        //                                 return;
        //                             }

        //                             const isGeneratedContent = 
        //                                 node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
        //                                 node.closest('#signals-strong, #signals-weak, #signals-ai') ||
        //                                 node.closest('#steepv-content, #futures-triangle-content') ||
        //                                 node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
        //                                 node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
        //                                 node.closest('#wind-tunnel-results, #analysis-grid') ||
        //                                 node.id && (
        //                                     node.id.includes('steepv-') || 
        //                                     node.id.includes('triangle-') || 
        //                                     node.id.includes('outcomes') ||
        //                                     node.id === 'mindmap-visualization'
        //                                 );
                                    
        //                             if (isGeneratedContent) {
        //                                 console.log('[OBSERVER] Translating new generated content');
        //                                 translateNewGeneratedContent(node);
        //                             }
        //                         }
        //                     });
        //                 }
        //             });
        //         }, 1000);
        //     }
        // });

        // document.addEventListener('DOMContentLoaded', function() {
        //     observer.observe(document.body, {
        //         childList: true,
        //         subtree: true
        //     });
        // });















// 14-10-2025
// i think no duplicate was found english to laos or english multiple text-- (but verify in some other method for conformation)
// start tomorrow to check it was translating multiple times or not

// 14-10-2025
// now starting for steepv and future triangle in phase 2
// steepv and future triangle also converted into laos language for that updated the renderSTEEPV and renderFuturesTriangle function
// in this below code nothing as changed , only update one line in collectElementsFromContainer
// added come css code for the steepv alignment

// 15-10-2025
// updated the toggleLanguage and restoreOriginalTexts for eng to laos and laos to eng translation it will not generate newly , it will show the first translated output
// newly added restoreLaoFromCache for not regenerate again the laos translation

// working function
        // async function toggleLanguage() {
        //     if (isTranslating) {
        //         console.log(`[LANG] Translation already in progress, skipping`);
        //         return;
        //     }
            
        //     const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
        //     const toggleBtn = document.getElementById('language-toggle-btn');
        //     const flagSpan = document.getElementById('language-flag');
        //     const textSpan = document.getElementById('language-text');
            
        //     console.log(`\n[LANG TOGGLE] Starting: ${currentLanguage} ‚Üí ${targetLanguage}`);
        //     console.log(`[LANG TOGGLE] Cache: ${translationCache.size} entries, Pending: ${pendingTranslations.size}\n`);
            
        //     // Clear any pending translations
        //     pendingTranslations.clear();
            
        //     isTranslating = true;
        //     document.body.classList.add('translating');
        //     toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
        //     try {
        //         if (targetLanguage === 'lo') {
        //             console.log(`[LANG] Initiating EN‚ÜíLO translation`);
        //             await translateGeneratedContent();
        //             flagSpan.textContent = 'üá±üá¶';
        //             textSpan.textContent = 'LO';
        //         } else {
        //             console.log(`[LANG] Restoring original English text`);
        //             restoreOriginalTexts();
        //             flagSpan.textContent = 'üá¨üáß';
        //             textSpan.textContent = 'EN';
        //         }
                
        //         currentLanguage = targetLanguage;
        //         console.log(`[LANG TOGGLE] Completed successfully\n`);
                
        //     } catch (error) {
        //         console.error('[LANG ERROR]', error);
        //         alert('Translation failed. Please try again.');
        //     } finally {
        //         isTranslating = false;
        //         document.body.classList.remove('translating');
        //         toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
                
        //         // Final cleanup
        //         pendingTranslations.clear();
        //     }
        // }


// updated this for the eng-lo or lo-eng again and again means it will not translate newly, just it will show the before translated output
        async function toggleLanguage() {
            if (isTranslating) {
                console.log(`[LANG] Translation already in progress, skipping`);
                return;
            }
            
            const targetLanguage = currentLanguage === 'en' ? 'lo' : 'en';
            const toggleBtn = document.getElementById('language-toggle-btn');
            const flagSpan = document.getElementById('language-flag');
            const textSpan = document.getElementById('language-text');
            
            console.log(`\n[LANG TOGGLE] Starting: ${currentLanguage} ‚Üí ${targetLanguage}`);
            console.log(`[LANG TOGGLE] Cache: ${translationCache.size} entries, Lao Cache: ${laoTranslations.size}\n`);
            
            // Clear any pending translations
            pendingTranslations.clear();
            
            isTranslating = true;
            document.body.classList.add('translating');
            toggleBtn.innerHTML = '<span>‚è≥</span> Translating...';
            
            try {
                if (targetLanguage === 'lo') {
                    console.log(`[LANG] Switching to Lao`);
                    
                    // Check if we have cached Lao translations
                    if (laoTranslations.size > 0) {
                        console.log(`[LANG] Using cached Lao translations (${laoTranslations.size} elements)`);
                        restoreLaoFromCache();
                    } else {
                        console.log(`[LANG] First time translation - initiating EN‚ÜíLO translation`);
                        await translateGeneratedContent();
                    }
                    
                    flagSpan.textContent = 'üá±üá¶';
                    textSpan.textContent = 'LO';
                } else {
                    console.log(`[LANG] Restoring original English text`);
                    restoreOriginalTexts();
                    flagSpan.textContent = 'üá¨üáß';
                    textSpan.textContent = 'EN';
                }
                
                currentLanguage = targetLanguage;
                console.log(`[LANG TOGGLE] Completed successfully\n`);
                
            } catch (error) {
                console.error('[LANG ERROR]', error);
                alert('Translation failed. Please try again.');
            } finally {
                isTranslating = false;
                document.body.classList.remove('translating');
                toggleBtn.innerHTML = `<span id="language-flag">${flagSpan.textContent}</span><span id="language-text">${textSpan.textContent}</span>`;
                
                // Final cleanup
                pendingTranslations.clear();
            }
        }




        // updated to check multiple api calls
        // async function translateGeneratedContent() {
        //     console.log(`\n${'='.repeat(60)}`);
        //     console.log(`[TRANSLATE CONTENT] Starting full content translation`);
        //     console.log(`[TRANSLATE CONTENT] Current phase: ${currentPhase}`);
        //     console.log(`${'='.repeat(60)}\n`);
            
        //     const elementsToTranslate = [];
        //     let totalCollected = 0;

        //     // Define containers to process
        //     const containersToProcess = [
        //         { id: 'domain-map-content', name: 'domain-map' },
        //         { id: 'mindmap-visualization', name: 'mind-map', isSVG: true },
        //         { id: 'interview-analysis-content', name: 'interview-analysis' },
        //         { id: 'signals-strong', name: 'signals-strong' },
        //         { id: 'signals-weak', name: 'signals-weak' },
        //         { id: 'signals-ai', name: 'signals-ai' },
        //         { id: 'steepv-content', name: 'steepv' },
        //         { id: 'futures-triangle-content', name: 'futures-triangle' },
        //         { id: 'futures-triangle-2-content', name: 'futures-triangle-2' },
        //         { id: 'baseline-scenario-content', name: 'baseline-scenario' },
        //         { id: 'driver-outcomes-results', name: 'driver-outcomes' },
        //         { id: 'alternative-scenarios-content', name: 'alt-scenarios' },
        //         { id: 'wind-tunnel-results', name: 'wind-tunnel' }
        //     ];

        //     // Process each container
        //     for (const containerDef of containersToProcess) {
        //         const container = document.getElementById(containerDef.id);
                
        //         if (!container || container.style.display === 'none') {
        //             continue;
        //         }

        //         console.log(`[PHASE-CHECK] Processing ${containerDef.name}`);

        //         if (containerDef.isSVG) {
        //             // Handle SVG elements specially
        //             const svg = container.querySelector('svg');
        //             if (svg) {
        //                 const textElements = svg.querySelectorAll('text');
        //                 textElements.forEach(textEl => {
        //                     if (!originalTexts.has(textEl)) {
        //                         const text = textEl.textContent.trim();
        //                         if (text && !containsLaoScript(text)) {
        //                             originalTexts.set(textEl, text);
        //                             elementsToTranslate.push(textEl);
        //                             totalCollected++;
        //                         }
        //                     }
        //                 });
        //             }
        //         } else {
        //             // Handle regular HTML elements
        //             const elementsInPhase = collectElementsFromContainer(container, containerDef.name);
        //             elementsToTranslate.push(...elementsInPhase);
        //             totalCollected += elementsInPhase.length;
        //         }
        //     }


        //     // ADD THIS DIRECTLY IN YOUR translateGeneratedContent() FUNCTION
        //     // After processing the main containersToProcess loop
        //     // ===== STEEPV TRANSLATION =====
        //     console.log(`[PHASE-CHECK] Processing STEEPV`);
        //     const steepvContent = document.getElementById('steepv-content');
        //     if (steepvContent && steepvContent.style.display !== 'none') {
        //         const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
        //         categories.forEach(cat => {
        //             const element = document.getElementById(`steepv-${cat}`);
        //             if (!element) return;

        //             const items = element.textContent.trim().split('\n').filter(item => item.trim());
        //             items.forEach((item, index) => {
        //                 const cleanItem = item.replace(/^[‚Ä¢\-\s]+/, '').trim();
        //                 if (!cleanItem || cleanItem.length < 10 || containsLaoScript(cleanItem)) return;

        //                 const normalizedText = normalizeText(cleanItem);
        //                 if (!uniqueTranslationTexts.has(normalizedText)) {
        //                     originalTexts.set(element, cleanItem); // Store just text, not key
        //                     uniqueTranslationTexts.add(normalizedText);
        //                     elementsToTranslate.push(element);
        //                     totalCollected++;
        //                 }
        //             });
        //         });
        //     }

        //     // ===== FUTURES TRIANGLE TRANSLATION =====
        //     console.log(`[PHASE-CHECK] Processing Futures Triangle`);
        //     const triangleContent = document.getElementById('futures-triangle-content');
        //     if (triangleContent && triangleContent.style.display !== 'none') {
        //         const triangleSections = ['triangle-future', 'triangle-present', 'triangle-past', 'dynamics-tensions', 'dynamics-alignment', 'dynamics-uncertainties'];
                
        //         triangleSections.forEach(sectionId => {
        //             const element = document.getElementById(sectionId);
        //             if (!element) return;

        //             const items = element.innerHTML
        //                 .split(/<br\s*\/?>/i)
        //                 .map(item => item.replace(/^[‚Ä¢\-\s]+/, '').replace(/<[^>]*>/g, '').trim())
        //                 .filter(item => item && item.length > 10);

        //             items.forEach((item) => {
        //                 if (containsLaoScript(item)) return;

        //                 const normalizedText = normalizeText(item);
        //                 if (!uniqueTranslationTexts.has(normalizedText)) {
        //                     originalTexts.set(element, item);
        //                     uniqueTranslationTexts.add(normalizedText);
        //                     elementsToTranslate.push(element);
        //                     totalCollected++;
        //                 }
        //             });
        //         });
        //     }

        //     // Also handle contenteditable elements
        //     console.log(`[PHASE-CHECK] Processing contenteditable elements`);
        //     const editableElements = document.querySelectorAll('[contenteditable="true"]');
        //     editableElements.forEach(element => {
        //         if (element.style.display === 'none') return;
                
        //         const text = element.textContent.trim();
        //         const normalizedText = normalizeText(text);
                
        //         if (text && 
        //             text.length >= 10 &&
        //             !text.includes('Click to add') && 
        //             !originalTexts.has(element) && 
        //             !containsLaoScript(text) &&
        //             !uniqueTranslationTexts.has(normalizedText)) {
                    
        //             originalTexts.set(element, text);
        //             uniqueTranslationTexts.add(normalizedText);
        //             elementsToTranslate.push(element);
        //             totalCollected++;
        //         }
        //     });

        //     console.log(`\n[SUMMARY] Total elements collected: ${totalCollected}`);
        //     console.log(`[SUMMARY] Starting batch translation with batch size 10\n`);

        //     // Batch translate with larger batch size
        //     const batchSize = 10;
        //     for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
        //         const batch = elementsToTranslate.slice(i, i + batchSize);
        //         const batchNum = Math.floor(i / batchSize) + 1;
        //         const totalBatches = Math.ceil(elementsToTranslate.length / batchSize);
                
        //         console.log(`[BATCH] ${batchNum}/${totalBatches} - Processing ${batch.length} elements`);
        //         await translateBatch(batch);
                
        //         // Small delay between batches
        //         await new Promise(resolve => setTimeout(resolve, 200));
        //     }

        //     console.log(`\n[COMPLETE] Translation of all content finished\n`);
        // }


        async function translateGeneratedContent() {
            console.log(`\n${'='.repeat(60)}`);
            console.log(`[TRANSLATE CONTENT] Starting full content translation`);
            console.log(`[TRANSLATE CONTENT] Current phase: ${currentPhase}`);
            console.log(`${'='.repeat(60)}\n`);
            
            const elementsToTranslate = [];
            let totalCollected = 0;

            // Define containers to process
            const containersToProcess = [
                { id: 'domain-map-content', name: 'domain-map' },
                { id: 'mindmap-visualization', name: 'mind-map', isSVG: true },
                { id: 'interview-analysis-content', name: 'interview-analysis' },
                { id: 'signals-strong', name: 'signals-strong' },
                { id: 'signals-weak', name: 'signals-weak' },
                { id: 'signals-ai', name: 'signals-ai' },
                { id: 'steepv-content', name: 'steepv' },
                { id: 'futures-triangle-content', name: 'futures-triangle' },
                { id: 'futures-triangle-2-content', name: 'futures-triangle-2' },
                { id: 'baseline-scenario-content', name: 'baseline-scenario' },
                { id: 'driver-outcomes-results', name: 'driver-outcomes' },
                { id: 'alternative-scenarios-content', name: 'alt-scenarios' },
                { id: 'wind-tunnel-results', name: 'wind-tunnel' }
            ];

            // Process each container
            for (const containerDef of containersToProcess) {
                const container = document.getElementById(containerDef.id);
                
                if (!container || container.style.display === 'none') {
                    continue;
                }

                console.log(`[PHASE-CHECK] Processing ${containerDef.name}`);

                if (containerDef.isSVG) {
                    // Handle SVG elements specially
                    const svg = container.querySelector('svg');
                    if (svg) {
                        const textElements = svg.querySelectorAll('text');
                        textElements.forEach(textEl => {
                            if (!originalTexts.has(textEl)) {
                                const text = textEl.textContent.trim();
                                if (text && !containsLaoScript(text)) {
                                    originalTexts.set(textEl, text);
                                    elementsToTranslate.push(textEl);
                                    totalCollected++;
                                }
                            }
                        });
                    }
                } else {
                    // Handle regular HTML elements
                    const elementsInPhase = collectElementsFromContainer(container, containerDef.name);
                    elementsToTranslate.push(...elementsInPhase);
                    totalCollected += elementsInPhase.length;
                }
            }

            // Also handle contenteditable elements
            console.log(`[PHASE-CHECK] Processing contenteditable elements`);
            const editableElements = document.querySelectorAll('[contenteditable="true"]');
            editableElements.forEach(element => {
                if (element.style.display === 'none') return;
                
                const text = element.textContent.trim();
                const normalizedText = normalizeText(text);
                
                if (text && 
                    text.length >= 10 &&
                    !text.includes('Click to add') && 
                    !originalTexts.has(element) && 
                    !containsLaoScript(text) &&
                    !uniqueTranslationTexts.has(normalizedText)) {
                    
                    originalTexts.set(element, text);
                    uniqueTranslationTexts.add(normalizedText);
                    elementsToTranslate.push(element);
                    totalCollected++;
                }
            });

            console.log(`\n[SUMMARY] Total elements collected: ${totalCollected}`);
            console.log(`[SUMMARY] Starting batch translation with batch size 10\n`);

            // Batch translate with larger batch size
            const batchSize = 10;
            for (let i = 0; i < elementsToTranslate.length; i += batchSize) {
                const batch = elementsToTranslate.slice(i, i + batchSize);
                const batchNum = Math.floor(i / batchSize) + 1;
                const totalBatches = Math.ceil(elementsToTranslate.length / batchSize);
                
                console.log(`[BATCH] ${batchNum}/${totalBatches} - Processing ${batch.length} elements`);
                await translateBatch(batch);
                
                // Small delay between batches
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            console.log(`\n[COMPLETE] Translation of all content finished\n`);
        }





        // newly added to check multiple api calls
        // ADD THIS NEW HELPER FUNCTION:
        function collectElementsFromContainer(container, containerName) {
            console.log(`  [COLLECT] Scanning: ${containerName}`);
            const elements = [];
            let skipped = 0;
            let collected = 0;

            // const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, strong, em, span, div');
            // const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, strong, em, span.translatable, div');
            const htmlElements = container.querySelectorAll('p, h4, h5, h6, li, strong, em, span.translatable, div > span.translatable');
     

            htmlElements.forEach(element => {
                // SKIP 0: Elements marked to skip translation
                if (element.classList.contains('skip-translation')) {
                    return;
                }
                
                // SKIP 1: Already processed
                if (element.dataset.translationProcessed === 'true') {
                    skipped++;
                    return;
                }

                // SKIP 2: Already has Lao script
                if (containsLaoScript(element.textContent)) {
                    skipped++;
                    return;
                }

                // SKIP 3: Already tracked in originalTexts
                if (originalTexts.has(element)) {
                    skipped++;
                    return;
                }

                const text = element.textContent.trim();

                // SKIP 4: Text is too short (min 20 chars to avoid labels)
                if (!text || text.length < 20) {
                    return;
                }

                // SKIP 5: UI elements or buttons
                if (isUIElement(element)) {
                    return;
                }

                // SKIP 6: UI labels
                if (isUILabel(text)) {
                    return;
                }

                // SKIP 7: Contains HTML
                if (text.includes('<') || text.includes('>')) {
                    return;
                }

                // SKIP 8: Only emoji/bullets
                if (text.match(/^[‚ñ∂‚ö°üéØüìäüîç‚ö†Ô∏è‚öôÔ∏èüí™üîÑüìÑüí°üé§üîçüíæ‚úÖ‚ùå]/)) {
                    return;
                }

                // SKIP 9: Duplicate check - don't translate same text twice (normalized)
                const normalizedText = normalizeText(text);
                if (uniqueTranslationTexts.has(normalizedText)) {
                    console.log(`    [SKIP-DUP] Already scheduled: "${text.substring(0, 30)}..."`);
                    skipped++;
                    return;
                }
                
                // SKIP 10: Check if already in cache
                const cacheKey = `${normalizedText}_lo`;
                if (translationCache.has(cacheKey)) {
                    console.log(`    [SKIP-CACHE] In cache: "${text.substring(0, 30)}..."`);
                    // Apply cached translation immediately
                    element.textContent = translationCache.get(cacheKey);
                    element.dataset.translated = 'true';
                    element.dataset.translationProcessed = 'true';
                    skipped++;
                    return;
                }

                // If we got here, add it for translation
                originalTexts.set(element, text);
                uniqueTranslationTexts.add(normalizedText); // Mark as scheduled with normalized text
                element.dataset.translationProcessed = 'true';
                elements.push(element);
                collected++;
            });

            console.log(`  [COLLECT] Collected: ${collected}, Skipped: ${skipped}`);
            return elements;
        }



        // updated to check multiple api calls
        async function translateBatch(elements) {
            console.log(`  [BATCH] Processing ${elements.length} elements`);
            
            // STEP 1: Group elements by their text content
            const textToElements = new Map();
            
            elements.forEach(element => {
                const originalContent = originalTexts.get(element);
                if (!originalContent) return;
                
                // Use normalized text as key to group identical texts
                const normalizedText = normalizeText(originalContent);
                
                if (!textToElements.has(normalizedText)) {
                    textToElements.set(normalizedText, []);
                }
                textToElements.get(normalizedText).push(element);
            });
            
            console.log(`  [BATCH] Deduplicated: ${elements.length} elements ‚Üí ${textToElements.size} unique texts`);
            
            // STEP 2: Process each unique text only once
            const promises = Array.from(textToElements.entries()).map(async ([normalizedText, elementGroup], index) => {
                const firstElement = elementGroup[0];
                const originalContent = originalTexts.get(firstElement);
                
                if (!originalContent) {
                    console.log(`    [SKIP-${index}] No original content`);
                    return;
                }

                // Skip if already contains Lao
                if (containsLaoScript(originalContent)) {
                    console.log(`    [SKIP-${index}] Already Lao`);
                    return;
                }

                // Check if already marked as translated
                if (firstElement.dataset?.translated === 'true') {
                    console.log(`    [SKIP-${index}] Already marked as translated`);
                    return;
                }

                try {
                    let textToTranslate = originalContent;

                    // Clean the text
                    if (typeof textToTranslate === 'string') {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = textToTranslate;
                        textToTranslate = tempDiv.textContent || tempDiv.innerText || textToTranslate;
                        textToTranslate = textToTranslate.trim();
                    }

                    // Validation
                    if (!textToTranslate || textToTranslate.length < 10) {
                        console.log(`    [SKIP-${index}] Text too short`);
                        return;
                    }

                    if (textToTranslate.includes('<') || textToTranslate.includes('>')) {
                        console.log(`    [SKIP-${index}] Contains HTML`);
                        return;
                    }

                    if (containsLaoScript(textToTranslate)) {
                        console.log(`    [SKIP-${index}] Text is already Lao`);
                        return;
                    }

                    // Check cache first
                    const cacheKey = `${normalizedText}_lo`;
                    
                    if (translationCache.has(cacheKey)) {
                        const cachedText = translationCache.get(cacheKey);
                        console.log(`    [CACHE-${index}] Hit for ${elementGroup.length} element(s): "${textToTranslate.substring(0, 35)}..."`);
                        
                        // Apply cached translation to ALL elements with same text
                        elementGroup.forEach(el => {
                            el.textContent = cachedText;
                            el.dataset.translated = 'true';
                        });
                        return;
                    }

                    // CRITICAL: Check if this text is already being translated
                    if (pendingTranslations.has(normalizedText)) {
                        console.log(`    [WAIT-${index}] Translation already in progress for ${elementGroup.length} element(s), waiting...`);
                        
                        try {
                            // Wait for the existing translation to complete
                            const translatedText = await pendingTranslations.get(normalizedText);
                            
                            // Apply the result to all elements
                            elementGroup.forEach(el => {
                                el.textContent = translatedText;
                                el.dataset.translated = 'true';
                            });
                            
                            console.log(`    [WAIT-${index}] ‚úì Applied result from pending translation`);
                        } catch (error) {
                            console.error(`    [WAIT-${index}] ‚ùå Pending translation failed:`, error.message);
                        }
                        
                        return;
                    }

                    console.log(`    [API-${index}] NEW translation for ${elementGroup.length} element(s) (${textToTranslate.length}ch): "${textToTranslate.substring(0, 40)}..."`);

                    // Create the translation promise
                    const translationPromise = (async () => {
                        const response = await fetch('/api/translate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                text: textToTranslate,
                                target_language: 'lo',
                                source_language: 'en'
                            })
                        });

                        const data = await response.json();

                        if (!data.success || !data.translated_text) {
                            throw new Error(data.error || 'Translation failed');
                        }

                        return data.translated_text;
                    })();

                    // Store the promise IMMEDIATELY to prevent duplicate calls
                    pendingTranslations.set(normalizedText, translationPromise);

                    try {
                        // Await the translation
                        const translatedText = await translationPromise;
                        
                        console.log(`    [SUCCESS-${index}] ‚úì Translated for ${elementGroup.length} element(s): "${translatedText.substring(0, 40)}..."`);
                        
                        // Apply to ALL elements with the same text
                        elementGroup.forEach(el => {
                            el.textContent = translatedText;
                            el.dataset.translated = 'true';
                        });
                        
                        // Store in cache
                        translationCache.set(cacheKey, translatedText);
                        
                    } catch (error) {
                        console.error(`    [ERROR-${index}] Translation failed:`, error.message);
                    } finally {
                        // Clean up: Remove from pending map
                        pendingTranslations.delete(normalizedText);
                    }

                } catch (error) {
                    console.error(`    [EXCEPTION-${index}]`, error.message);
                    // Make sure to clean up pending map
                    pendingTranslations.delete(normalizedText);
                }
            });

            await Promise.all(promises);
            
            console.log(`  [BATCH] Completed. Pending translations: ${pendingTranslations.size}`);
        }



        // DEBUG: Add a function to check current state
        function debugTranslationState() {
            console.log('=== TRANSLATION STATE DEBUG ===');
            console.log('Current Language:', currentLanguage);
            console.log('Is Translating:', isTranslating);
            console.log('Original Texts Count:', originalTexts.size);
            console.log('Translation Cache Count:', translationCache.size);
            console.log('Unique Translation Texts:', uniqueTranslationTexts.size);
            
            // Check for any Lao content in the page
            const allText = document.body.textContent;
            const hasLao = containsLaoScript(allText);
            console.log('Page contains Lao script:', hasLao);
            
            // Check translated elements
            const translatedElements = document.querySelectorAll('[data-translated="true"]');
            console.log('Elements marked as translated:', translatedElements.length);
            
            // Check elements with Lao content
            let laoElementCount = 0;
            document.querySelectorAll('*').forEach(el => {
                if (containsLaoScript(el.textContent)) {
                    laoElementCount++;
                }
            });
            console.log('Elements with Lao content:', laoElementCount);
            console.log('===============================');
        }

        // DEBUG: Show deduplication stats
        // DEBUG: Show deduplication stats
        function debugDeduplication() {
            console.log('=== DEDUPLICATION DEBUG ===');
            console.log('Original Texts Map:', originalTexts.size);
            console.log('Translation Cache:', translationCache.size);
            console.log('Pending Translations:', pendingTranslations.size);
            console.log('Unique Translation Texts:', uniqueTranslationTexts.size);
            
            // Show what's currently pending
            if (pendingTranslations.size > 0) {
                console.log('\nCurrently pending:');
                Array.from(pendingTranslations.keys()).forEach((key, i) => {
                    console.log(`  ${i + 1}. "${key.substring(0, 50)}..."`);
                });
            }
            
            // Check for duplicate texts in originalTexts
            const textCounts = new Map();
            originalTexts.forEach((text, element) => {
                const normalized = normalizeText(text);
                textCounts.set(normalized, (textCounts.get(normalized) || 0) + 1);
            });
            
            const duplicates = Array.from(textCounts.entries()).filter(([text, count]) => count > 1);
            if (duplicates.length > 0) {
                console.log(`\nFound ${duplicates.length} duplicate texts:`);
                duplicates.forEach(([text, count]) => {
                    console.log(`  "${text.substring(0, 40)}..." appears ${count} times`);
                });
            } else {
                console.log('\nNo duplicate texts found in originalTexts map');
            }
            
            console.log('===========================');
        }

        // Call after translation: debugDeduplication()



        // Call this function in console to debug: debugTranslationState()

        // updated to check multiple api calls
        // function restoreOriginalTexts() {
        //     console.log(`[RESTORE] Starting restoration of original English text`);
            
        //     // Clear pending translations
        //     pendingTranslations.clear();
            
        //     let restored = 0;
        //     let skipped = 0;

        //     originalTexts.forEach((originalContent, element) => {
        //         // Skip SVG elements and non-string content
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') {
        //             skipped++;
        //             return;
        //         }

        //         try {
        //             element.textContent = originalContent;
        //             delete element.dataset.translated;
        //             delete element.dataset.translationProcessed;
        //             restored++;
        //         } catch (error) {
        //             console.error(`[RESTORE ERROR]`, error);
        //             skipped++;
        //         }
        //     });

        //     console.log(`[RESTORE] Completed - Restored: ${restored}, Skipped: ${skipped}`);
            
        //     // Clear caches when going back to English
        //     uniqueTranslationTexts.clear();
        //     console.log(`[RESTORE] Cleared translation cache for next translation cycle`);
        // }


// updated this function for steepv and future triangle,when click the toggle button laos to eng means this two was coming empty remaing all are converted into english
        // function restoreOriginalTexts() {
        //     console.log(`[RESTORE] Starting restoration of original English text`);
            
        //     // Clear pending translations
        //     pendingTranslations.clear();
            
        //     let restored = 0;
        //     let skipped = 0;

        //     originalTexts.forEach((originalContent, element) => {
        //         // Skip SVG elements and non-string content
        //         if (element.tagName === 'svg' || typeof originalContent !== 'string') {
        //             skipped++;
        //             return;
        //         }

        //         try {
        //             element.textContent = originalContent;
        //             delete element.dataset.translated;
        //             delete element.dataset.translationProcessed;
        //             restored++;
        //         } catch (error) {
        //             console.error(`[RESTORE ERROR]`, error);
        //             skipped++;
        //         }
        //     });

        //     // ADD THIS: Special handling for STEEPV contenteditable cells
        //     const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
        //     categories.forEach(cat => {
        //         const element = document.getElementById(`steepv-${cat}`);
        //         if (element && element.dataset.originalEnglish) {
        //             try {
        //                 const originalData = JSON.parse(element.dataset.originalEnglish);
        //                 const formattedItems = originalData.map(text => 
        //                     `<div style="margin-bottom: 8px; display: block; clear: both;"><span class="translatable">‚Ä¢ ${text}</span></div>`
        //                 ).join('');
        //                 element.innerHTML = formattedItems;
        //                 restored++;
        //             } catch (e) {
        //                 console.error('[RESTORE ERROR] STEEPV:', e);
        //             }
        //         }
        //     });

        //     // ADD THIS: Special handling for Futures Triangle contenteditable cells
        //     const triangleElements = [
        //         'triangle-future', 'triangle-present', 'triangle-past',
        //         'dynamics-tensions', 'dynamics-alignment', 'dynamics-uncertainties'
        //     ];
            
        //     triangleElements.forEach(elemId => {
        //         const element = document.getElementById(elemId);
        //         if (element && element.dataset.originalEnglish) {
        //             try {
        //                 const originalData = JSON.parse(element.dataset.originalEnglish);
                        
        //                 if (Array.isArray(originalData)) {
        //                     // Simple array format
        //                     element.innerHTML = originalData.map(item => 
        //                         `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
        //                     ).join('');
        //                 } else {
        //                     // Object format with sections
        //                     let html = '';
        //                     for (const [key, items] of Object.entries(originalData)) {
        //                         if (Array.isArray(items) && items.length > 0) {
        //                             const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        //                             html += `<div style="margin-bottom: 1rem;">`;
        //                             html += `<strong class="translatable">${sectionTitle}:</strong><br>`;
        //                             html += items.map(item => 
        //                                 `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
        //                             ).join('');
        //                             html += `</div>`;
        //                         }
        //                     }
        //                     element.innerHTML = html || '<div><span class="translatable">No items identified</span></div>';
        //                 }
        //                 restored++;
        //             } catch (e) {
        //                 console.error('[RESTORE ERROR] Futures Triangle:', e);
        //             }
        //         }
        //     });

        //     console.log(`[RESTORE] Completed - Restored: ${restored}, Skipped: ${skipped}`);
            
        //     // Clear caches when going back to English
        //     uniqueTranslationTexts.clear();
        //     console.log(`[RESTORE] Cleared translation cache for next translation cycle`);
        // }



// updated this function for steepv and future triangle,when click the toggle button laos to eng means this two was coming empty remaing all are converted into english
// updated this again for the eng-lo or lo-eng again and again it was translate newly that wrong, just it will show the before translated output
        function restoreOriginalTexts() {
            console.log(`[RESTORE] Starting restoration of original English text`);
            
            // Clear pending translations
            pendingTranslations.clear();
            
            let restored = 0;
            let skipped = 0;

            // First, store current Lao content before restoring English
            originalTexts.forEach((originalContent, element) => {
                // Skip SVG elements and non-string content
                if (element.tagName === 'svg' || typeof originalContent !== 'string') {
                    skipped++;
                    return;
                }

                try {
                    // Store Lao version if it exists and is different from original
                    const currentContent = element.innerHTML || element.textContent;
                    if (currentContent && currentContent !== originalContent && containsLaoScript(currentContent)) {
                        laoTranslations.set(element, currentContent);
                    }
                    
                    // Restore English
                    element.textContent = originalContent;
                    delete element.dataset.translated;
                    restored++;
                } catch (error) {
                    console.error(`[RESTORE ERROR]`, error);
                    skipped++;
                }
            });

            // Special handling for STEEPV contenteditable cells
            const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
            categories.forEach(cat => {
                const element = document.getElementById(`steepv-${cat}`);
                if (element && element.dataset.originalEnglish) {
                    try {
                        // Store current Lao HTML before restoring
                        const currentLaoHtml = element.innerHTML;
                        if (currentLaoHtml && containsLaoScript(currentLaoHtml)) {
                            laoTranslations.set(element, currentLaoHtml);
                        }
                        
                        // Restore English
                        const originalData = JSON.parse(element.dataset.originalEnglish);
                        const formattedItems = originalData.map(text => 
                            `<div style="margin-bottom: 8px; display: block; clear: both;"><span class="translatable">‚Ä¢ ${text}</span></div>`
                        ).join('');
                        element.innerHTML = formattedItems;
                        delete element.dataset.translated;
                        restored++;
                    } catch (e) {
                        console.error('[RESTORE ERROR] STEEPV:', e);
                    }
                }
            });

            // Special handling for Futures Triangle contenteditable cells
            const triangleElements = [
                'triangle-future', 'triangle-present', 'triangle-past',
                'dynamics-tensions', 'dynamics-alignment', 'dynamics-uncertainties'
            ];
            
            triangleElements.forEach(elemId => {
                const element = document.getElementById(elemId);
                if (element && element.dataset.originalEnglish) {
                    try {
                        // Store current Lao HTML before restoring
                        const currentLaoHtml = element.innerHTML;
                        if (currentLaoHtml && containsLaoScript(currentLaoHtml)) {
                            laoTranslations.set(element, currentLaoHtml);
                        }
                        
                        // Restore English
                        const originalData = JSON.parse(element.dataset.originalEnglish);
                        
                        if (Array.isArray(originalData)) {
                            // Simple array format
                            element.innerHTML = originalData.map(item => 
                                `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
                            ).join('');
                        } else {
                            // Object format with sections
                            let html = '';
                            for (const [key, items] of Object.entries(originalData)) {
                                if (Array.isArray(items) && items.length > 0) {
                                    const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                                    html += `<div style="margin-bottom: 1rem;">`;
                                    html += `<strong class="translatable">${sectionTitle}:</strong><br>`;
                                    html += items.map(item => 
                                        `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
                                    ).join('');
                                    html += `</div>`;
                                }
                            }
                            element.innerHTML = html || '<div><span class="translatable">No items identified</span></div>';
                        }
                        delete element.dataset.translated;
                        restored++;
                    } catch (e) {
                        console.error('[RESTORE ERROR] Futures Triangle:', e);
                    }
                }
            });

            console.log(`[RESTORE] Completed - Restored: ${restored}, Skipped: ${skipped}`);
            console.log(`[RESTORE] Stored ${laoTranslations.size} Lao translations in cache`);
        }


        function restoreLaoFromCache() {
            console.log(`[RESTORE LAO] Restoring ${laoTranslations.size} cached Lao translations`);
            
            let restored = 0;
            
            laoTranslations.forEach((laoContent, element) => {
                try {
                    if (element.tagName === 'svg') return;
                    
                    // Restore Lao content
                    if (element.innerHTML !== undefined) {
                        element.innerHTML = laoContent;
                    } else {
                        element.textContent = laoContent;
                    }
                    element.dataset.translated = 'true';
                    restored++;
                } catch (error) {
                    console.error('[RESTORE LAO ERROR]', error);
                }
            });
            
            console.log(`[RESTORE LAO] Completed - Restored ${restored} elements from cache`);
        }


        async function translateNewGeneratedContent(element) {
            console.log('[TRANSLATE NEW] Starting translation check for new content');
            
            // CRITICAL: Skip if element already has Lao content anywhere
            if (hasAnyLaoContent(element)) {
                console.log('[TRANSLATE NEW] Skipping - element already contains Lao text');
                return;
            }

            // CRITICAL: Skip if already marked as translated
            if (element && element.dataset?.translated === 'true') {
                console.log('[TRANSLATE NEW] Skipping - element already marked as translated');
                return;
            }

            const elementsToTranslate = [];
            
            const htmlElements = element.querySelectorAll('p, h4, h5, h6, li, td, span, strong, em');
            
            htmlElements.forEach(el => {
                // Skip if this specific element contains Lao
                if (containsLaoScript(el.textContent)) {
                    console.log('[TRANSLATE NEW] Skipping element - already has Lao:', el.textContent.substring(0, 30));
                    return;
                }

                // Skip if already translated
                if (el.dataset?.translated === 'true') {
                    return;
                }

                // Skip if already in originalTexts (being processed)
                if (originalTexts.has(el)) {
                    return;
                }

                if (!isUIElement(el)) {
                    const text = el.textContent.trim();
                    if (text && text.length > 5) {
                        originalTexts.set(el, text);
                        elementsToTranslate.push(el);
                    }
                }
            });
            
            const editableElements = element.querySelectorAll('[contenteditable="true"]');
            editableElements.forEach(el => {
                if (containsLaoScript(el.textContent)) {
                    return;
                }

                if (el.dataset?.translated === 'true') {
                    return;
                }

                const text = el.textContent.trim();
                if (text && text.length > 5 && !text.includes('Click to add') && 
                    !originalTexts.has(el)) {
                    originalTexts.set(el, text);
                    elementsToTranslate.push(el);
                }
            });

            const translatableElements = element.querySelectorAll('.translatable');
            translatableElements.forEach(el => {
                if (containsLaoScript(el.textContent)) {
                    return;
                }

                if (el.dataset?.translated === 'true') {
                    return;
                }

                if (!originalTexts.has(el) && !isUILabel(el.textContent)) {
                    const text = el.textContent.trim();
                    if (text && text.length > 3) {
                        originalTexts.set(el, text);
                        elementsToTranslate.push(el);
                    }
                }
            });

            // Mark container as translated BEFORE starting translation
            if (element) {
                element.dataset.translated = 'true';
            }
            
            console.log(`[TRANSLATE NEW] Found ${elementsToTranslate.length} elements to translate`);
            
            if (elementsToTranslate.length > 0) {
                await translateBatch(elementsToTranslate);
            }
        }

        function isUILabel(text) {
            const labels = [
                'Impact', 'Certainty', 'Category', 'Trajectory', 'Possible outcomes', 
                'Influence', 'Type', 'Outcomes possible', 'Category:', 'Trajectory:', 
                'Possible outcomes:', 'Influence areas:', 'Type:', 'Resolution:', 
                'Impact Impact', 'Current trajectory', 'Source:', 'Potential:', 'Relevance:',
                'Issue Areas:', 'Strong', 'Weak', 'Medium', 'High', 'Low', 'Rationale:',
                // Technical terms that should not be translated
                'Collapse/Decline', 'New Equilibrium', 'Transformation', 
                'Key Factors', 'Critical Assumptions', 'Early Warning Indicators',
                'VIABILITY', 'PROCESS', 'CAPABILITIES', 'ADAPTATIONS NEEDED',
                'Collapse', 'Decline', 'Equilibrium', 'Story Shift', 'Key Variables',
                'Dominant Drivers', 'Timeframe'
            ];
            return labels.some(label => text.includes(label));
        }

        function isUIElement(element) {
            const uiClasses = ['btn', 'button', 'nav', 'navbar', 'sidebar', 'phase-item', 'tab', 'upload-area'];
            const uiTags = ['button', 'nav', 'input', 'select', 'textarea'];
            
            if (uiClasses.some(cls => element.classList.contains(cls))) return true;
            if (uiTags.includes(element.tagName.toLowerCase())) return true;
            if (element.closest('.btn, .button, nav, .navbar, .sidebar, .phase-item, .tab, .upload-area')) return true;
            
            return false;
        }


        // updated to check multiple api calls
        // Normalize text for better caching
        function normalizeText(text) {
            if (!text) return '';
            return text.trim().replace(/\s+/g, ' ').toLowerCase();
        }

        function hasAnyLaoContent(element) {
            if (!element) return false;
            
            // Check the element's own text
            if (containsLaoScript(element.textContent)) {
                return true;
            }
            
            // Check if element has been marked as translated
            if (element.dataset?.translated === 'true') {
                return true;
            }
            
            // Check if any child has Lao content
            const allText = element.querySelectorAll('*');
            for (let el of allText) {
                if (containsLaoScript(el.textContent) || el.dataset?.translated === 'true') {
                    return true;
                }
            }
            
            return false;
        }


        function containsLaoScript(text) {
            if (!text) return false;
            return /[\u0E80-\u0EFF]/.test(text);
        }

        function isAlreadyTranslated(element) {
            if (!element) return false;
            const text = element.textContent || element.innerText || '';
            return containsLaoScript(text);
        }

        const observer = new MutationObserver((mutations) => {
            if (currentLanguage === 'lo' && !isTranslating) {
                clearTimeout(translationTimeout);
                translationTimeout = setTimeout(() => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    // IMPROVED: Skip if node already contains Lao
                                    if (hasAnyLaoContent(node)) {
                                        console.log('[OBSERVER] Skipping node - already has Lao content');
                                        return;
                                    }

                                    // IMPROVED: Skip if node is marked as translated
                                    if (node.dataset?.translated === 'true') {
                                        console.log('[OBSERVER] Skipping node - already marked translated');
                                        return;
                                    }

                                    const isGeneratedContent = 
                                        node.closest('#domain-map-content, #mindmap-content, #interview-analysis-content') ||
                                        node.closest('#signals-strong, #signals-weak, #signals-ai') ||
                                        node.closest('#steepv-content, #futures-triangle-content') ||
                                        node.closest('#futures-triangle-2-content, #baseline-scenario-content') ||
                                        node.closest('#driver-outcomes-results, #alternative-scenarios-content') ||
                                        node.closest('#wind-tunnel-results, #analysis-grid') ||
                                        node.id && (
                                            node.id.includes('steepv-') || 
                                            node.id.includes('triangle-') || 
                                            node.id.includes('outcomes') ||
                                            node.id === 'mindmap-visualization'
                                        );
                                    
                                    if (isGeneratedContent) {
                                        console.log('[OBSERVER] Translating new generated content');
                                        translateNewGeneratedContent(node);
                                    }
                                }
                            });
                        }
                    });
                }, 1000);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });

































        // API Functions
        async function generateDomainMap() {
            const button = event.target.closest('.btn-ai');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;
            const out = document.getElementById('domain-map-content');
            try {
                const projectName = document.getElementById('project-name').value.trim();
                const domain = resolveFinalDomain();
                if (!projectName) throw new Error('Please enter project name');
                if (!domain) throw new Error('Please select or enter domain');
                const form = new FormData();
                form.append('project_name', projectName);
                form.append('final_domain', domain);
                (uploadedFiles.documents || []).forEach(f => form.append('documents', f));
                const res = await fetch('/api/generate-domain-map', { method: 'POST', body: form });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate domain map');
                const dm = data.domain_map || {};
                out.style.display = 'block';
                out.innerHTML = renderDomainMap(dm);

                // Add these lines after successful rendering
                window.savedDomainMapData = dm; // Store the domain map data
                document.getElementById('mindmap-btn').style.display = 'inline-block'; // Show mind map button
                // document.getElementById('refine-btn').style.display = 'inline-block'; // Also show refine button
            } catch (err) {
                alert(err.message || 'Error generating domain map');
            } finally {
                button.innerHTML = '<span>ü§ñ</span> Generate Domain Map';
                button.disabled = false;
            }
        }

        async function refineDomainMap() {
            const button = document.getElementById('refine-btn');
            button.innerHTML = '<span>‚è≥</span> Refining...';
            button.disabled = true;
            
            // For now, just re-generate the domain map
            try {
                await generateDomainMap();
            } catch (err) {
                console.error('Error refining domain map:', err);
            } finally {
                button.innerHTML = '<span>üîß</span> Refine Existing Map';
                button.disabled = false;
            }
        }

        async function generateMindMap() {
            const button = document.getElementById('mindmap-btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please generate domain map first');

                // Get the current domain map data
                const domainMapData = window.savedDomainMapData || {};
                
                const form = new FormData();
                form.append('domain_map', JSON.stringify(domainMapData));
                form.append('domain', domain);

                const res = await fetch('/api/generate-mindmap', {
                    method: 'POST',
                    body: form
                });

                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate mind map');

                // Show mind map content
                document.getElementById('mindmap-content').style.display = 'block';
                renderMindMap(data.mindmap_data);

            } catch (err) {
                alert(err.message || 'Error generating mind map');
            } finally {
                button.innerHTML = '<span>üß†</span> Generate Mind Map';
                button.disabled = false;
            }
        }

        async function analyzeInterviews() {
            const button = document.getElementById('analyze-interviews-btn');
            const container = document.getElementById('interview-analysis-content');
            const wrap = document.getElementById('interview-analysis');
            button.innerHTML = '<span>‚è≥</span> Analyzing...';
            button.disabled = true;

            try {
                const form = new FormData();
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please select or enter domain in Phase 1');
                form.append('domain', domain);
                (uploadedFiles.interviews || []).forEach(f => form.append('interviews', f));

                const res = await fetch('/api/analyze-interviews', { method: 'POST', body: form });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to analyze');

                const analysis = data.interview_analysis || {};
                wrap.style.display = 'block';
                container.innerHTML = renderInterviewAnalysis(analysis);
            } catch (err) {
                alert(err.message || 'Error analyzing interviews');
            } finally {
                button.innerHTML = '<span>üìä</span> Analyze Interview Data';
                button.disabled = false;
            }
        }

        // UPDATE 1: In generateSignals() function - around line 480
        async function generateSignals() {
            const button = event.target.closest('.btn-ai');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            try {
                const form = new FormData();
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set project name and domain in Phase 1');
                form.append('domain', domain);
                
                // UPDATED: Include ALL document types with proper field names
                (uploadedFiles.documents || []).forEach(f => form.append('documents', f));
                (uploadedFiles.signals || []).forEach(f => form.append('signals', f));
                (uploadedFiles.interviews || []).forEach(f => form.append('interviews', f));
                
                // ADD: Also include domain map if uploaded separately
                if (uploadedFiles.domainMap) {
                    form.append('domain_map', uploadedFiles.domainMap);
                }

                const res = await fetch('/api/generate-signals', { method: 'POST', body: form });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate signals');

                lastSignalsData = data.signals_data || {};
                
                // Enable buttons and show signals section
                document.getElementById('ai-suggestions-btn').disabled = false;
                document.getElementById('generate-steepv-btn').disabled = false;
                document.getElementById('signals-section').style.display = 'block';
                
                renderSignalsTabs(lastSignalsData);
            } catch (err) {
                alert(err.message || 'Error generating signals');
            } finally {
                button.innerHTML = '<span>üîç</span> Generate Strong & Weak Signals';
                button.disabled = false;
            }
        }

        async function generateAISuggestions() {
            const button = event.target.closest('.btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;
            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');
                if (!lastSignalsData) throw new Error('Generate signals first');
                const res = await fetch('/api/generate-ai-suggestions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ domain, signals_data: lastSignalsData })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate suggestions');
                const list = Array.isArray(data.suggestions) ? data.suggestions : [];
                document.getElementById('signals-ai').style.display = 'block';
                document.getElementById('signals-ai').innerHTML = list.map(renderAISuggestion).join('') || '<p>No suggestions</p>';
            } catch (err) {
                alert(err.message || 'Error generating AI suggestions');
            } finally {
                button.innerHTML = '<span>üí°</span> Generate AI Suggestions';
                button.disabled = false;
            }
        }

        // UPDATE 2: In generateSTEEPV() function - around line 550
        async function generateSTEEPV() {
            const button = document.getElementById('generate-steepv-btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');
                if (!lastSignalsData) throw new Error('Generate signals first');

                const form = new FormData();
                form.append('domain', domain);
                form.append('signals_data', JSON.stringify(lastSignalsData));
                
                // UPDATED: Include ALL document types
                (uploadedFiles.documents || []).forEach(f => form.append('documents', f));
                (uploadedFiles.signals || []).forEach(f => form.append('signals', f));
                (uploadedFiles.interviews || []).forEach(f => form.append('interviews', f));
                
                // ADD: Include domain map
                if (uploadedFiles.domainMap) {
                    form.append('domain_map', uploadedFiles.domainMap);
                }

                const res = await fetch('/api/generate-steepv', { method: 'POST', body: form });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate STEEPV analysis');

                const steepv = data.steepv || {};
                document.getElementById('steepv-content').style.display = 'block';
                document.getElementById('generate-triangle-btn').disabled = false;
                renderSTEEPV(steepv);
            } catch (err) {
                alert(err.message || 'Error generating STEEPV analysis');
            } finally {
                button.innerHTML = '<span>üìä</span> Generate STEEPV Analysis';
                button.disabled = false;
            }
        }


        // Tab Switching for Signals
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('tab')) {
                const tab = e.target;
                const group = tab.parentElement;
                group.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const type = tab.dataset.tab;
                document.getElementById('signals-strong').style.display = (type === 'strong') ? 'block' : 'none';
                document.getElementById('signals-weak').style.display = (type === 'weak') ? 'block' : 'none';
                document.getElementById('signals-ai').style.display = (type === 'ai-suggestions') ? 'block' : 'none';
            }
        });

        // UPDATE 3: In generateFuturesTriangle() function - around line 620
        async function generateFuturesTriangle() {
            const button = document.getElementById('generate-triangle-btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');
                if (!lastSignalsData) throw new Error('Generate signals first');

                // Get STEEPV data from the rendered content
                const steepvData = {};
                const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
                categories.forEach(cat => {
                    const element = document.getElementById(`steepv-${cat}`);
                    steepvData[cat] = element ? element.innerHTML : '';
                });

                // UPDATED: Include comprehensive document context
                const payload = {
                    domain,
                    signals_data: lastSignalsData,
                    steepv_data: steepvData,
                    document_context: {
                        has_documents: (uploadedFiles.documents || []).length > 0,
                        has_interviews: (uploadedFiles.interviews || []).length > 0,
                        has_signals: (uploadedFiles.signals || []).length > 0,
                        has_domain_map: !!uploadedFiles.domainMap
                    }
                };

                // ADD: Include file data in the request
                const form = new FormData();
                form.append('request_data', JSON.stringify(payload));
                
                // Include all document types
                (uploadedFiles.documents || []).forEach(f => form.append('documents', f));
                (uploadedFiles.signals || []).forEach(f => form.append('signals', f));
                (uploadedFiles.interviews || []).forEach(f => form.append('interviews', f));
                if (uploadedFiles.domainMap) {
                    form.append('domain_map', uploadedFiles.domainMap);
                }

                const res = await fetch('/api/generate-futures-triangle', {
                    method: 'POST',
                    body: form  // Changed from JSON to FormData to include files
                });

                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate futures triangle');

                const triangle = data.futures_triangle || {};
                document.getElementById('futures-triangle-content').style.display = 'block';
                renderFuturesTriangle(triangle);
            } catch (err) {
                alert(err.message || 'Error generating futures triangle');
            } finally {
                button.innerHTML = '<span>üìä</span> Generate Futures Triangle';
                button.disabled = false;
            }
        }

        // ADD: Save STEEPV function
        async function saveSTEEPV() {
            const button = document.getElementById('save-steepv-btn');
            button.innerHTML = '<span>‚è≥</span> Saving...';
            button.disabled = true;
            
            try {
                // Collect edited STEEPV data
                const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
                const steepvData = {};
                
                categories.forEach(cat => {
                    const element = document.getElementById(`steepv-${cat}`);
                    steepvData[cat] = element ? element.innerHTML.trim() : '';
                });
                
                // Store in global variable for next phase
                savedSTEEPVData = steepvData;
                
                // Optional: Send to server to save
                const domain = resolveFinalDomain();
                const response = await fetch('/api/save-steepv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ domain, steepv_data: steepvData })
                });
                
                if (response.ok) {
                    // Visual feedback
                    button.innerHTML = '<span>‚úÖ</span> Saved Successfully';
                    setTimeout(() => {
                        button.innerHTML = '<span>üíæ</span> Save STEEPV Analysis';
                        button.disabled = false;
                    }, 2000);
                } else {
                    throw new Error('Failed to save');
                }
            } catch (err) {
                console.error('Save error:', err);
                button.innerHTML = '<span>‚ùå</span> Save Failed';
                setTimeout(() => {
                    button.innerHTML = '<span>üíæ</span> Save STEEPV Analysis';
                    button.disabled = false;
                }, 2000);
            }
        }

        // ADD: Save Futures Triangle function
        async function saveFuturesTriangle() {
            const button = document.getElementById('save-triangle-btn');
            button.innerHTML = '<span>‚è≥</span> Saving...';
            button.disabled = true;
            
            try {
                // Collect edited Futures Triangle data
                const triangleData = {
                    pull_of_future: document.getElementById('triangle-future')?.innerHTML.trim() || '',
                    push_of_present: document.getElementById('triangle-present')?.innerHTML.trim() || '',
                    weight_of_history: document.getElementById('triangle-past')?.innerHTML.trim() || '',
                    key_dynamics: {
                        primary_tensions: document.getElementById('dynamics-tensions')?.innerHTML.trim() || '',
                        alignment_opportunities: document.getElementById('dynamics-alignment')?.innerHTML.trim() || '',
                        critical_uncertainties: document.getElementById('dynamics-uncertainties')?.innerHTML.trim() || ''
                    }
                };
                
                // Store in global variable for next phase
                savedFuturesTriangleData = triangleData;
                
                // Optional: Send to server to save
                const domain = resolveFinalDomain();
                const response = await fetch('/api/save-futures-triangle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ domain, futures_triangle_data: triangleData })
                });
                
                if (response.ok) {
                    // Visual feedback
                    button.innerHTML = '<span>‚úÖ</span> Saved Successfully';
                    setTimeout(() => {
                        button.innerHTML = '<span>üíæ</span> Save Futures Triangle';
                        button.disabled = false;
                    }, 2000);
                } else {
                    throw new Error('Failed to save');
                }
            } catch (err) {
                console.error('Save error:', err);
                button.innerHTML = '<span>‚ùå</span> Save Failed';
                setTimeout(() => {
                    button.innerHTML = '<span>üíæ</span> Save Futures Triangle';
                    button.disabled = false;
                }, 2000);
            }
        }

        // ADD: Save Phase 1 Progress function
        async function savePhase1Progress() {
            const button = event.target.closest('.btn');
            const originalText = button.innerHTML;
            button.innerHTML = '<span>‚è≥</span> Saving...';
            button.disabled = true;
            
            try {
                // Collect all Phase 1 data
                const projectName = document.getElementById('project-name').value.trim();
                const domainSelect = document.getElementById('domain-select').value;
                const newDomainName = document.getElementById('new-domain-name').value.trim();
                const finalDomain = resolveFinalDomain();
                
                // Get domain map content if generated
                const domainMapContent = document.getElementById('domain-map-content').innerHTML;
                const domainMapVisible = document.getElementById('domain-map-content').style.display !== 'none';
                
                // Get interview analysis content if generated
                const interviewAnalysisContent = document.getElementById('interview-analysis-content').innerHTML;
                const interviewAnalysisVisible = document.getElementById('interview-analysis').style.display !== 'none';
                
                // Prepare data object
                const phase1Data = {
                    project_name: projectName,
                    domain_select: domainSelect,
                    new_domain_name: newDomainName,
                    final_domain: finalDomain,
                    domain_map_generated: domainMapVisible,
                    domain_map_content: domainMapVisible ? domainMapContent : '',
                    interview_analysis_generated: interviewAnalysisVisible,
                    interview_analysis_content: interviewAnalysisVisible ? interviewAnalysisContent : '',
                    uploaded_files: {
                        domain_map_files: uploadedFiles.domainMap ? uploadedFiles.domainMap.name : null,
                        interview_files: uploadedFiles.interviews ? uploadedFiles.interviews.map(f => f.name) : [],
                        documents_count: uploadedFiles.documents ? uploadedFiles.documents.length : 0
                    },
                    timestamp: new Date().toISOString()
                };
                
                // Store in global variable
                savedPhase1Data = phase1Data;
                
                // Store in localStorage for persistence
                localStorage.setItem('phase1_progress', JSON.stringify(phase1Data));
                
                // Optional: Send to server
                const response = await fetch('/api/save-phase1-progress', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(phase1Data)
                });
                
                if (response.ok) {
                    // Success feedback
                    button.innerHTML = '<span>‚úÖ</span> Saved Successfully';
                    
                    // Show success message
                    showSuccessMessage('Phase 1 progress saved successfully!');
                    
                } else {
                    throw new Error('Server save failed');
                }
                
            } catch (err) {
                console.error('Save error:', err);
                // Even if server fails, local storage still works
                if (savedPhase1Data) {
                    button.innerHTML = '<span>‚úÖ</span> Saved Locally';
                    showSuccessMessage('Progress saved locally!');
                } else {
                    button.innerHTML = '<span>‚ùå</span> Save Failed';
                    showErrorMessage('Failed to save progress. Please try again.');
                }
            } finally {
                // Reset button after 2 seconds
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }

        async function generateFuturesTriangle2() {
            const button = event.target.closest('.btn-ai');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');

                // Get saved data from previous phases
                const phase1Data = savedPhase1Data || JSON.parse(localStorage.getItem('phase1_progress') || '{}');
                const phase2Data = {
                    signals_data: lastSignalsData || {},
                    steepv_data: savedSTEEPVData || {},
                    futures_triangle_data: savedFuturesTriangleData || {}
                };

                // Prepare form data
                const form = new FormData();
                form.append('domain', domain);
                form.append('phase1_data', JSON.stringify(phase1Data));
                form.append('phase2_data', JSON.stringify(phase2Data));

                // Include all uploaded files for context
                (uploadedFiles.documents || []).forEach(f => form.append('documents', f));
                (uploadedFiles.signals || []).forEach(f => form.append('signals', f));
                (uploadedFiles.interviews || []).forEach(f => form.append('interviews', f));
                if (uploadedFiles.domainMap) {
                    form.append('domain_map', uploadedFiles.domainMap);
                }

                const res = await fetch('/api/generate-futures-triangle-2-0', {
                    method: 'POST',
                    body: form
                });

                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate Futures Triangle 2.0');

                const triangle2 = data.futures_triangle_2_0 || {};
                
                // Show the content section
                document.getElementById('futures-triangle-2-content').style.display = 'block';
                
                // Render the results
                renderFuturesTriangle2(triangle2);
                
                // Enable next step (Baseline Scenario)
                document.getElementById('baseline-btn').disabled = false;
                
                // Store for next steps
                window.savedTriangle2Data = triangle2;

            } catch (err) {
                alert(err.message || 'Error generating Futures Triangle 2.0');
            } finally {
                button.innerHTML = '<span>üî∫</span> Generate Analysis';
                button.disabled = false;
            }
        }

        async function generateBaselineScenario() {
            const button = document.getElementById('baseline-btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            // ADD THESE LINES TO CLEAR EXISTING CONTENT:
            document.getElementById('baseline-scenario-content').style.display = 'none';
            document.getElementById('baseline-text').innerHTML = '';
            document.getElementById('baseline-title').textContent = '';

            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');
                
                // Check if Futures Triangle 2.0 data exists
                if (!window.savedTriangle2Data) {
                    throw new Error('Please generate Futures Triangle 2.0 first');
                }

                const payload = {
                    domain: domain,
                    triangle_2_0_data: window.savedTriangle2Data,
                    phase1_data: savedPhase1Data || {}
                };

                const res = await fetch('/api/generate-baseline-scenario', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate baseline scenario');

                const baseline = data.baseline_scenario || {};
                
                // Show the content section
                document.getElementById('baseline-scenario-content').style.display = 'block';
                
                // Render the baseline scenario
                renderBaselineScenario(baseline);
                
                // Enable next step (Driver Outcomes)
                document.getElementById('driver-outcomes-btn').disabled = false;
                
                // Store for next steps
                window.savedBaselineData = baseline;

            } catch (err) {
                alert(err.message || 'Error generating baseline scenario');
            } finally {
                button.innerHTML = '<span>üìà</span> Generate Baseline Scenario';
                button.disabled = false;
            }
        }

        async function generateDriverOutcomes() {
            const button = document.getElementById('driver-outcomes-btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;
            
            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');
                
                // Check required data exists
                if (!window.savedTriangle2Data) {
                    throw new Error('Please generate Futures Triangle 2.0 first');
                }
                if (!window.savedBaselineData) {
                    throw new Error('Please generate Baseline Scenario first');
                }
                
                const payload = {
                    domain: domain,
                    triangle_2_0_data: window.savedTriangle2Data,
                    baseline_data: window.savedBaselineData,
                    phase1_data: savedPhase1Data || {}
                };

                const res = await fetch('/api/generate-driver-outcomes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                

                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate driver outcomes');
                
                const outcomes = data.driver_outcomes || {};
                
                // Show content section
                document.getElementById('driver-outcomes-content').style.display = 'block';
                
                // Render the outcomes
                renderDriverOutcomes(outcomes);
                
                // Enable next step
                document.getElementById('alt-scenarios-btn').disabled = false;
                
                // Store for next steps
                window.savedDriverOutcomes = outcomes;
                
            } catch (err) {
                alert(err.message || 'Error generating driver outcomes');
            } finally {
                button.innerHTML = '<span>üéØ</span> Generate Driver Outcomes';
                button.disabled = false;
            }
        }

        async function generateAlternativeScenarios() {
            const button = document.getElementById('alt-scenarios-btn');
            button.innerHTML = '<span>‚è≥</span> Generating...';
            button.disabled = true;

            try {
                const domain = resolveFinalDomain();
                if (!domain) throw new Error('Please set domain in Phase 1');
                
                // Get user selections
                const collapseCount = parseInt(document.getElementById('collapse-count').value);
                const newEquilibriumCount = parseInt(document.getElementById('new-equilibrium-count').value);
                const transformationCount = parseInt(document.getElementById('transformation-count').value);
                
                if (collapseCount + newEquilibriumCount + transformationCount === 0) {
                    throw new Error('Please select at least one scenario to generate');
                }
                
                // Check required data exists
                if (!window.savedBaselineData) {
                    throw new Error('Please generate Baseline Scenario first');
                }
                if (!window.savedDriverOutcomes) {
                    throw new Error('Please generate Driver Outcomes first');
                }
                
                const payload = {
                    domain: domain,
                    collapse_count: collapseCount,
                    new_equilibrium_count: newEquilibriumCount,
                    transformation_count: transformationCount,
                    baseline_data: window.savedBaselineData,
                    driver_outcomes: window.savedDriverOutcomes,
                    triangle_2_0_data: window.savedTriangle2Data || {}
                };
                
                const res = await fetch('/api/generate-alternative-scenarios', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to generate scenarios');
                
                const scenarios = data.alternative_scenarios || {};
                
                // Show content section
                document.getElementById('alternative-scenarios-content').style.display = 'block';
                
                // Render the scenarios
                renderAlternativeScenarios(scenarios);
                
                // Store for next steps or export
                window.savedAlternativeScenarios = scenarios;
                
            } catch (err) {
                alert(err.message || 'Error generating alternative scenarios');
            } finally {
                button.innerHTML = '<span>üîÆ</span> Generate Alternative Scenarios';
                button.disabled = false;
            }
        }

        // Helper Functions
        function resolveFinalDomain() {
            const select = document.getElementById('domain-select');
            const newDom = document.getElementById('new-domain-name').value.trim();
            if (select.value === 'new') return newDom || '';
            const map = {
                'food-security': 'Food Security & Self-Sufficiency',
                'human-capital': 'Human Capital & TVET',
                'sme-fiscal': 'SMEs & Fiscal Policy',
                'renewable-energy': 'Renewable Energy',
                'digital-economy': 'Digital Economy'
            };
            return map[select.value] || '';
        }

        function renderSignalsTabs(signals) {
            const strong = extractSignals(signals, 'strong_signals');
            const weak = extractSignals(signals, 'weak_signals');
            const strongEl = document.getElementById('signals-strong');
            const weakEl = document.getElementById('signals-weak');
            strongEl.innerHTML = strong.map(renderSignalCardStrong).join('') || '<p>No strong signals found</p>';
            weakEl.innerHTML = weak.map(renderSignalCardWeak).join('') || '<p>No weak signals found</p>';
            strongEl.style.display = 'block';
            weakEl.style.display = 'none';
            document.querySelector('#signals-tabs .tab[data-tab="strong"]').click();
        }

        function extractSignals(obj, key) {
            if (!obj) return [];
            if (Array.isArray(obj[key])) return obj[key];
            if (obj.raw_response) {
                try {
                    const m = obj.raw_response.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                    const parsed = JSON.parse(m ? m[1] : obj.raw_response);
                    return Array.isArray(parsed[key]) ? parsed[key] : [];
                } catch (_) { return []; }
            }
            return [];
        }

        // function renderSignalCardStrong(s) {
        //     const title = (s && s.title) || 'Strong Signal';
        //     const desc = (s && s.description) || '';
        //     const source = (s && s.source) || 'Document Analysis';
        //     const impact = (s && s.impact) || 'High impact';
        //     return `<div class="signal-card strong"><h4>üü¢ ${title}</h4><p>${desc}</p><small><strong>Source:</strong> ${source}</small><br><small><strong>Impact:</strong> ${impact}</small></div>`;
        // }

        // function renderSignalCardWeak(s) {
        //     const title = (s && s.title) || 'Weak Signal';
        //     const desc = (s && s.description) || '';
        //     const source = (s && s.source) || 'Document Analysis';
        //     const potential = (s && s.potential) || 'Emerging trend';
        //     return `<div class="signal-card weak"><h4>üü° ${title}</h4><p>${desc}</p><small><strong>Source:</strong> ${source}</small><br><small><strong>Potential:</strong> ${potential}</small></div>`;
        // }

        // function renderAISuggestion(s) {
        //     const title = (s && s.title) || 'AI Suggestion';
        //     const desc = (s && s.description) || '';
        //     const category = (s && s.category) || 'Weak';
        //     const rationale = (s && s.rationale) || '';
        //     const cls = category === 'Strong' ? 'strong' : 'weak';
        //     return `<div class="signal-card ${cls}"><h4>üí° ${title}</h4><p>${desc}</p><small><strong>Category:</strong> ${category}</small><br><small><strong>Rationale:</strong> ${rationale}</small></div>`;
        // }

// working code 
        function renderSignalCardStrong(s) {
            const title = (s && s.title) || 'Strong Signal';
            const desc = (s && s.description) || '';
            const source = (s && s.source) || 'Document Analysis';
            const impact = (s && s.impact) || 'High impact';
            return `<div class="signal-card strong">
                <h4>üü¢ ${title}</h4>
                <p>${desc}</p>
                <small><strong>Source:</strong> <span class="translatable-value">${source}</span></small><br>
                <small><strong>Impact:</strong> <span class="translatable-value">${impact}</span></small>
            </div>`;
        }

        function renderSignalCardWeak(s) {
            const title = (s && s.title) || 'Weak Signal';
            const desc = (s && s.description) || '';
            const source = (s && s.source) || 'Document Analysis';
            const potential = (s && s.potential) || 'Emerging trend';
            return `<div class="signal-card weak">
                <h4>üü° ${title}</h4>
                <p>${desc}</p>
                <small><strong>Source:</strong> <span class="translatable-value">${source}</span></small><br>
                <small><strong>Potential:</strong> <span class="translatable-value">${potential}</span></small>
            </div>`;
        }

        function renderAISuggestion(s) {
            const title = (s && s.title) || 'AI Suggestion';
            const desc = (s && s.description) || '';
            const category = (s && s.category) || 'Weak';
            const rationale = (s && s.rationale) || '';
            const cls = category === 'Strong' ? 'strong' : 'weak';
            return `<div class="signal-card ${cls}">
                <h4>üí° ${title}</h4>
                <p>${desc}</p>
                <small><strong>Category:</strong> <span class="translatable-value">${category}</span></small><br>
                <small><strong>Rationale:</strong> <span class="translatable-value">${rationale}</span></small>
            </div>`;
        }






        function renderInterviewAnalysis(analysis) {
            const challenges = (analysis && analysis.challenges) || [];
            const opportunities = (analysis && analysis.opportunities) || [];
            const visions = (analysis && analysis.visions) || [];
            return `
                <div class="cards-grid">
                    <div class="card"><h4>üéØ Top Challenges</h4><ul>${challenges.map(i => `<li>${i}</li>`).join('')}</ul></div>
                    <div class="card"><h4>üí° Key Opportunities</h4><ul>${opportunities.map(i => `<li>${i}</li>`).join('')}</ul></div>
                    <div class="card"><h4>üîÆ Future Visions</h4><ul>${visions.map(i => `<li>${i}</li>`).join('')}</ul></div>
                </div>`;
        }


        function renderDomainMap(dm) {
            const central = dm.central_domain || 'Domain Analysis';
            const desc = dm.description || '';
            const sub = Array.isArray(dm.sub_domains) ? dm.sub_domains : [];
            
            return `
                <div>
                    <h4>Central Domain: ${central}</h4>
                    ${desc ? `<p><em>${desc}</em></p>` : ''}
                    ${sub.length ? `
                        <div style="margin-top: 1rem;">
                            <h5>Sub-domains:</h5>
                            ${sub.map(s => `
                                <div class="signal-card" style="border-left-color:#9b59b6">
                                    <h5>${(s && s.name) || 'Sub-domain'}</h5>
                                    <p class="subdomain-description">${(s && s.description) || ''}</p>
                                    <p><strong>Relevance:</strong> ${(s && s.relevance) || 'Medium'}</p>
                                    ${(s && s.issue_areas && s.issue_areas.length) ? `
                                        <div style="margin-top: 0.5rem;">
                                            <strong>Issue Areas:</strong>
                                            <ul style="margin: 0.3rem 0; padding-left: 1.2rem;">
                                                ${s.issue_areas.map(issue => `<li>${issue}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>` : ''}
                </div>`;
        }


        function renderMindMap(mindmapData) {
            const container = document.getElementById('mindmap-visualization');
            container.innerHTML = '';
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '1000');
            svg.setAttribute('viewBox', '0 0 1600 1000');
            svg.style.background = 'white';
            
            const centralDomain = mindmapData.central_domain || 'Central Domain';
            const subDomains = mindmapData.sub_domains || [];
            
            // Better pastel color schemes with good contrast
            const clusterColors = [
                '#87CEEB', // Sky blue
                '#FFB347', // Peach
                '#DDA0DD', // Plum  
                '#98FB98', // Pale green
                '#F0E68C', // Khaki
                '#FFA07A', // Light salmon
                '#E6E6FA', // Lavender
                '#AFEEEE', // Pale turquoise
                '#FFDAB9'  // Peach puff
            ];
            
            const centerX = 800;
            const centerY = 500;
            
            // Central domain bubble (larger and darker)
            const centralBubble = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centralBubble.setAttribute('cx', centerX);
            centralBubble.setAttribute('cy', centerY);
            centralBubble.setAttribute('r', '85');
            centralBubble.setAttribute('fill', '#4A5568');
            centralBubble.setAttribute('stroke', '#2D3748');
            centralBubble.setAttribute('stroke-width', '2');
            svg.appendChild(centralBubble);
            
            // Helper function to create multi-line text
            function createMultiLineText(svgElement, x, y, text, fontSize, fontWeight, fill, maxWidth, maxLines = 2) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = [];
                
                // Improved word wrapping with better character count calculation
                const maxCharsPerLine = Math.floor(maxWidth / (fontSize * 0.5));
                
                words.forEach(word => {
                    const currentLineText = currentLine.join(' ');
                    if ((currentLineText + ' ' + word).length <= maxCharsPerLine || currentLine.length === 0) {
                        currentLine.push(word);
                    } else {
                        if (lines.length < maxLines - 1) {
                            lines.push(currentLine.join(' '));
                            currentLine = [word];
                        } else {
                            // Last line - add ellipsis if needed
                            const remainingWords = words.slice(words.indexOf(word));
                            const lastLine = currentLine.join(' ');
                            if (remainingWords.length > 0 && (lastLine + ' ' + word).length > maxCharsPerLine) {
                                lines.push(lastLine + '...');
                                currentLine = [];
                            } else {
                                currentLine.push(word);
                            }
                        }
                    }
                });
                
                if (currentLine.length > 0 && lines.length < maxLines) {
                    lines.push(currentLine.join(' '));
                }
                
                // Create text elements
                const lineHeight = fontSize * 1.2;
                const startY = y - ((lines.length - 1) * lineHeight) / 2;
                
                lines.forEach((line, index) => {
                    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textElement.setAttribute('x', x);
                    textElement.setAttribute('y', startY + (index * lineHeight));
                    textElement.setAttribute('text-anchor', 'middle');
                    textElement.setAttribute('dominant-baseline', 'middle');
                    textElement.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
                    textElement.setAttribute('font-size', fontSize);
                    textElement.setAttribute('font-weight', fontWeight);
                    textElement.setAttribute('fill', fill);
                    textElement.textContent = line;
                    svgElement.appendChild(textElement);
                });
            }
            
            // Central domain text
            createMultiLineText(svg, centerX, centerY, centralDomain, 14, 'bold', 'white', 150, 2);
            
            // Create clusters around the center
            subDomains.forEach((subDomain, clusterIndex) => {
                const clusterColor = clusterColors[clusterIndex % clusterColors.length];
                const clusterAngle = (clusterIndex / subDomains.length) * 2 * Math.PI;
                
                // Reduced cluster distance to 200
                const clusterDistance = 200;
                const clusterCenterX = centerX + Math.cos(clusterAngle) * clusterDistance;
                const clusterCenterY = centerY + Math.sin(clusterAngle) * clusterDistance;
                
                // Create sub-domain bubble
                const subDomainBubble = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                subDomainBubble.setAttribute('cx', clusterCenterX);
                subDomainBubble.setAttribute('cy', clusterCenterY);
                subDomainBubble.setAttribute('r', '70');
                subDomainBubble.setAttribute('fill', clusterColor);
                subDomainBubble.setAttribute('stroke', '#333');
                subDomainBubble.setAttribute('stroke-width', '2');
                svg.appendChild(subDomainBubble);
                
                // Sub-domain text
                const subDomainName = subDomain.name || 'Sub-domain';
                createMultiLineText(svg, clusterCenterX, clusterCenterY, subDomainName, 12, '600', '#000', 120, 2);
                
                // Add issue bubbles around the cluster center - ONLY ON THE RIGHT SIDE
                const issues = subDomain.issue_areas || [];
                
                if (issues.length > 0) {
                    // Calculate right side angle range (90 degrees to the right of clusterAngle)
                    const rightSideStartAngle = clusterAngle - Math.PI/4; // -45 degrees from cluster direction
                    const rightSideEndAngle = clusterAngle + Math.PI/4;   // +45 degrees from cluster direction
                    
                    // Define row structure: 3 issues in first row, 3 in second, 2 in third
                    const row1Count = Math.min(3, issues.length);
                    const row2Count = Math.min(3, issues.length - row1Count);
                    const row3Count = issues.length - row1Count - row2Count;
                    
                    issues.forEach((issue, issueIndex) => {
                        let row, col;
                        
                        // Determine row and column based on the 3-3-2 structure
                        if (issueIndex < row1Count) {
                            // First row: up to 3 issues
                            row = 0;
                            col = issueIndex;
                        } else if (issueIndex < row1Count + row2Count) {
                            // Second row: up to 3 issues
                            row = 1;
                            col = issueIndex - row1Count;
                        } else {
                            // Third row: remaining issues (usually 2)
                            row = 2;
                            col = issueIndex - row1Count - row2Count;
                        }
                        
                        // Calculate angle position within the row
                        let issueAngle;
                        if (row === 0 && row1Count === 1) {
                            // Single issue in first row - center it
                            issueAngle = (rightSideStartAngle + rightSideEndAngle) / 2;
                        } else if (row === 0 || row === 1) {
                            // First or second row with 3 issues - spread them out more
                            const angleStep = (rightSideEndAngle - rightSideStartAngle) / (row1Count > 1 ? row1Count : 1);
                            issueAngle = rightSideStartAngle + col * angleStep;
                        } else {
                            // Third row with 2 issues - center them with more spacing
                            if (row3Count === 1) {
                                // Single issue in third row - center it
                                issueAngle = (rightSideStartAngle + rightSideEndAngle) / 2;
                            } else {
                                // Two issues in third row - position with more spacing
                                issueAngle = rightSideStartAngle + ((col + 1) / (row3Count + 1)) * (rightSideEndAngle - rightSideStartAngle);
                            }
                        }
                        
                        // Calculate distance based on row - REDUCED DISTANCE STEP TO BRING ROWS CLOSER
                        const baseDistance = 180; // Keep first row distance unchanged
                        const distanceStep = 100; // Reduced from 150 to bring rows closer
                        const issueDistance = baseDistance + row * distanceStep;
                        
                        const issueX = clusterCenterX + Math.cos(issueAngle) * issueDistance;
                        const issueY = clusterCenterY + Math.sin(issueAngle) * issueDistance;
                        
                        // Slightly reduced bubble sizes to create more gap
                        const textLength = issue.length;
                        let bubbleRadius;
                        if (textLength <= 10) {
                            bubbleRadius = 35; // Reduced from 38
                        } else if (textLength <= 20) {
                            bubbleRadius = 40; // Reduced from 44
                        } else {
                            bubbleRadius = 45; // Reduced from 50
                        }
                        
                        // Issue bubble with dynamic sizing
                        const issueBubble = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        issueBubble.setAttribute('cx', issueX);
                        issueBubble.setAttribute('cy', issueY);
                        issueBubble.setAttribute('r', bubbleRadius);
                        issueBubble.setAttribute('fill', clusterColor);
                        issueBubble.setAttribute('stroke', '#333');
                        issueBubble.setAttribute('stroke-width', '1.5');
                        issueBubble.setAttribute('opacity', '0.9');
                        svg.appendChild(issueBubble);
                        
                        // Issue text with improved sizing
                        const maxTextWidth = bubbleRadius * 2.2;
                        createMultiLineText(svg, issueX, issueY, issue, 8, '500', '#000', maxTextWidth, 3);
                    });
                }
            });
            
            container.appendChild(svg);
        }

// old
        // function renderSTEEPV(steepv) {
        //     const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
        //     categories.forEach(cat => {
        //         const element = document.getElementById(`steepv-${cat}`);
        //         const data = steepv[cat] || steepv[cat.charAt(0).toUpperCase() + cat.slice(1)] || [];
        //         if (Array.isArray(data) && data.length > 0) {
        //             element.innerHTML = data.map(item => 
        //                 typeof item === 'string' ? `‚Ä¢ ${item}` : `‚Ä¢ ${item.title || item.signal || item}`
        //             ).join('<br>');
        //         } else {
        //             element.innerHTML = 'No signals identified for this category';
        //         }
        //     });
        // }

        // function renderFuturesTriangle(triangle) {
        //     // Extract the three main forces
        //     const pullOfFuture = triangle.pull_of_future || {};
        //     const pushOfPresent = triangle.push_of_present || {};
        //     const weightOfHistory = triangle.weight_of_history || {};
        //     const keyDynamics = triangle.key_dynamics || {};

        //     function formatDetailedItems(obj) {
        //         if (!obj) return 'No data available';
                
        //         let html = '';
        //         for (const [key, items] of Object.entries(obj)) {
        //             if (Array.isArray(items) && items.length > 0) {
        //                 const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        //                 html += `<div style="margin-bottom: 1rem;"><strong>${sectionTitle}:</strong><br>`;
        //                 html += items.map(item => `‚Ä¢ ${item}`).join('<br>');
        //                 html += '</div>';
        //             }
        //         }
        //         return html || 'No items identified';
        //     }

        //     function formatSimpleItems(items) {
        //         if (!Array.isArray(items) || items.length === 0) {
        //             return 'No items identified';
        //         }
        //         return items.map(item => `‚Ä¢ ${item}`).join('<br>');
        //     }

        //     // Render Pull of the Future (first)
        //     document.getElementById('triangle-future').innerHTML = formatDetailedItems(pullOfFuture);

        //     // Render Push of the Present (second)  
        //     document.getElementById('triangle-present').innerHTML = formatDetailedItems(pushOfPresent);

        //     // Render Weight of History (third)
        //     document.getElementById('triangle-past').innerHTML = formatDetailedItems(weightOfHistory);

        //     // Render Key Dynamics & Strategic Insights
        //     document.getElementById('dynamics-tensions').innerHTML = 
        //         formatSimpleItems(keyDynamics.primary_tensions) || 'No primary tensions identified';

        //     document.getElementById('dynamics-alignment').innerHTML = 
        //         formatSimpleItems(keyDynamics.alignment_opportunities) || 'No alignment opportunities identified';

        //     document.getElementById('dynamics-uncertainties').innerHTML = 
        //         formatSimpleItems(keyDynamics.critical_uncertainties) || 'No critical uncertainties identified';
        // }


// little bit good for the future triangle for laos translation but not for the steepv
        // function renderSTEEPV(steepv) {
        //     const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
        //     categories.forEach(cat => {
        //         const element = document.getElementById(`steepv-${cat}`);
        //         const data = steepv[cat] || steepv[cat.charAt(0).toUpperCase() + cat.slice(1)] || [];
        //         if (Array.isArray(data) && data.length > 0) {
        //             // ADD: Wrap each item in a span with translatable class
        //             element.innerHTML = data.map(item => {
        //                 const text = typeof item === 'string' ? item : (item.title || item.signal || item);
        //                 return `<span class="translatable">‚Ä¢ ${text}</span>`;
        //             }).join('<br>');
        //         } else {
        //             element.innerHTML = '<span class="translatable">No signals identified for this category</span>';
        //         }
        //     });
            
        //     // ADD: Trigger translation if in Lao mode
        //     if (currentLanguage === 'lo') {
        //         setTimeout(() => {
        //             const steepvContent = document.getElementById('steepv-content');
        //             if (steepvContent) {
        //                 translateNewGeneratedContent(steepvContent);
        //             }
        //         }, 100);
        //     }
        // }

        // function renderFuturesTriangle(triangle) {
        //     const pullOfFuture = triangle.pull_of_future || {};
        //     const pushOfPresent = triangle.push_of_present || {};
        //     const weightOfHistory = triangle.weight_of_history || {};
        //     const keyDynamics = triangle.key_dynamics || {};

        //     function formatDetailedItems(obj) {
        //         if (!obj) return '<span class="translatable">No data available</span>';
                
        //         let html = '';
        //         for (const [key, items] of Object.entries(obj)) {
        //             if (Array.isArray(items) && items.length > 0) {
        //                 const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        //                 html += `<div style="margin-bottom: 1rem;">
        //                     <strong class="translatable">${sectionTitle}:</strong><br>`;
        //                 // ADD: Wrap each item in translatable span
        //                 html += items.map(item => `<span class="translatable">‚Ä¢ ${item}</span>`).join('<br>');
        //                 html += '</div>';
        //             }
        //         }
        //         return html || '<span class="translatable">No items identified</span>';
        //     }

        //     function formatSimpleItems(items) {
        //         if (!Array.isArray(items) || items.length === 0) {
        //             return '<span class="translatable">No items identified</span>';
        //         }
        //         // ADD: Wrap each item in translatable span
        //         return items.map(item => `<span class="translatable">‚Ä¢ ${item}</span>`).join('<br>');
        //     }

        //     // Render sections
        //     document.getElementById('triangle-future').innerHTML = formatDetailedItems(pullOfFuture);
        //     document.getElementById('triangle-present').innerHTML = formatDetailedItems(pushOfPresent);
        //     document.getElementById('triangle-past').innerHTML = formatDetailedItems(weightOfHistory);
            
        //     document.getElementById('dynamics-tensions').innerHTML = 
        //         formatSimpleItems(keyDynamics.primary_tensions) || '<span class="translatable">No primary tensions identified</span>';

        //     document.getElementById('dynamics-alignment').innerHTML = 
        //         formatSimpleItems(keyDynamics.alignment_opportunities) || '<span class="translatable">No alignment opportunities identified</span>';

        //     document.getElementById('dynamics-uncertainties').innerHTML = 
        //         formatSimpleItems(keyDynamics.critical_uncertainties) || '<span class="translatable">No critical uncertainties identified</span>';
            
        //     // ADD: Trigger translation if in Lao mode
        //     if (currentLanguage === 'lo') {
        //         setTimeout(() => {
        //             const triangleContent = document.getElementById('futures-triangle-content');
        //             if (triangleContent) {
        //                 translateNewGeneratedContent(triangleContent);
        //             }
        //         }, 100);
        //     }
        // }


// super the steepv and future triangle also was converted into laos language , the only problem was steepv alignment
        // function renderSTEEPV(steepv) {
        //     const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
        //     categories.forEach(cat => {
        //         const element = document.getElementById(`steepv-${cat}`);
        //         const data = steepv[cat] || steepv[cat.charAt(0).toUpperCase() + cat.slice(1)] || [];
                
        //         if (Array.isArray(data) && data.length > 0) {
        //             // Create properly formatted list with translatable content
        //             const formattedItems = data.map(item => {
        //                 const text = typeof item === 'string' ? item : (item.title || item.signal || item);
        //                 return `<div style="margin-bottom: 8px;"><span class="translatable">‚Ä¢ ${text}</span></div>`;
        //             }).join('');
        //             element.innerHTML = formattedItems;
        //         } else {
        //             element.innerHTML = '<div><span class="translatable">No signals identified for this category</span></div>';
        //         }
        //     });
            
        //     // Trigger translation if in Lao mode
        //     if (currentLanguage === 'lo') {
        //         setTimeout(() => {
        //             const steepvContent = document.getElementById('steepv-content');
        //             if (steepvContent) {
        //                 console.log('[STEEPV] Triggering translation for STEEPV content');
        //                 translateNewGeneratedContent(steepvContent);
        //             }
        //         }, 100);
        //     }
        // }

        // function renderFuturesTriangle(triangle) {
        //     const pullOfFuture = triangle.pull_of_future || {};
        //     const pushOfPresent = triangle.push_of_present || {};
        //     const weightOfHistory = triangle.weight_of_history || {};
        //     const keyDynamics = triangle.key_dynamics || {};

        //     function formatDetailedItems(obj) {
        //         if (!obj) return '<div><span class="translatable">No data available</span></div>';
                
        //         let html = '';
        //         for (const [key, items] of Object.entries(obj)) {
        //             if (Array.isArray(items) && items.length > 0) {
        //                 const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        //                 html += `<div style="margin-bottom: 1rem;">`;
        //                 html += `<strong class="translatable">${sectionTitle}:</strong><br>`;
        //                 // Each item in its own div for better alignment
        //                 html += items.map(item => 
        //                     `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
        //                 ).join('');
        //                 html += `</div>`;
        //             }
        //         }
        //         return html || '<div><span class="translatable">No items identified</span></div>';
        //     }

        //     function formatSimpleItems(items) {
        //         if (!Array.isArray(items) || items.length === 0) {
        //             return '<div><span class="translatable">No items identified</span></div>';
        //         }
        //         // Each item in its own div with translatable span
        //         return items.map(item => 
        //             `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
        //         ).join('');
        //     }

        //     // Render the three forces
        //     document.getElementById('triangle-future').innerHTML = formatDetailedItems(pullOfFuture);
        //     document.getElementById('triangle-present').innerHTML = formatDetailedItems(pushOfPresent);
        //     document.getElementById('triangle-past').innerHTML = formatDetailedItems(weightOfHistory);
            
        //     // Render Key Dynamics - THIS WAS THE MISSING PART
        //     const tensionsHtml = formatSimpleItems(keyDynamics.primary_tensions);
        //     const alignmentHtml = formatSimpleItems(keyDynamics.alignment_opportunities);
        //     const uncertaintiesHtml = formatSimpleItems(keyDynamics.critical_uncertainties);
            
        //     document.getElementById('dynamics-tensions').innerHTML = tensionsHtml;
        //     document.getElementById('dynamics-alignment').innerHTML = alignmentHtml;
        //     document.getElementById('dynamics-uncertainties').innerHTML = uncertaintiesHtml;
            
        //     // Trigger translation if in Lao mode
        //     if (currentLanguage === 'lo') {
        //         setTimeout(() => {
        //             const triangleContent = document.getElementById('futures-triangle-content');
        //             if (triangleContent) {
        //                 console.log('[FUTURES TRIANGLE] Triggering translation for Futures Triangle content');
        //                 translateNewGeneratedContent(triangleContent);
        //             }
        //         }, 100);
        //     }
        // }


// updated this steepv for better alignment and add some css code for the alignment
        // function renderSTEEPV(steepv) {
        //     const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
        //     categories.forEach(cat => {
        //         const element = document.getElementById(`steepv-${cat}`);
        //         const data = steepv[cat] || steepv[cat.charAt(0).toUpperCase() + cat.slice(1)] || [];
                
        //         if (Array.isArray(data) && data.length > 0) {
        //             // Create a vertical list with each item on its own line
        //             const formattedItems = data.map(item => {
        //                 const text = typeof item === 'string' ? item : (item.title || item.signal || item);
        //                 // Use div with display:block to force vertical stacking
        //                 return `<div style="margin-bottom: 8px; display: block; clear: both;"><span class="translatable">‚Ä¢ ${text}</span></div>`;
        //             }).join('');
        //             element.innerHTML = formattedItems;
        //         } else {
        //             element.innerHTML = '<div style="display: block;"><span class="translatable">No signals identified for this category</span></div>';
        //         }
        //     });
            
        //     // Trigger translation if in Lao mode
        //     if (currentLanguage === 'lo') {
        //         setTimeout(() => {
        //             const steepvContent = document.getElementById('steepv-content');
        //             if (steepvContent) {
        //                 console.log('[STEEPV] Triggering translation for STEEPV content');
        //                 translateNewGeneratedContent(steepvContent);
        //             }
        //         }, 100);
        //     }
        // }

        // function renderFuturesTriangle(triangle) {
        //     const pullOfFuture = triangle.pull_of_future || {};
        //     const pushOfPresent = triangle.push_of_present || {};
        //     const weightOfHistory = triangle.weight_of_history || {};
        //     const keyDynamics = triangle.key_dynamics || {};

        //     function formatDetailedItems(obj) {
        //         if (!obj) return '<div><span class="translatable">No data available</span></div>';
                
        //         let html = '';
        //         for (const [key, items] of Object.entries(obj)) {
        //             if (Array.isArray(items) && items.length > 0) {
        //                 const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        //                 html += `<div style="margin-bottom: 1rem;">`;
        //                 html += `<strong class="translatable">${sectionTitle}:</strong><br>`;
        //                 // Each item in its own div for better alignment
        //                 html += items.map(item => 
        //                     `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
        //                 ).join('');
        //                 html += `</div>`;
        //             }
        //         }
        //         return html || '<div><span class="translatable">No items identified</span></div>';
        //     }

        //     function formatSimpleItems(items) {
        //         if (!Array.isArray(items) || items.length === 0) {
        //             return '<div><span class="translatable">No items identified</span></div>';
        //         }
        //         // Each item in its own div with translatable span
        //         return items.map(item => 
        //             `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
        //         ).join('');
        //     }

        //     // Render the three forces
        //     document.getElementById('triangle-future').innerHTML = formatDetailedItems(pullOfFuture);
        //     document.getElementById('triangle-present').innerHTML = formatDetailedItems(pushOfPresent);
        //     document.getElementById('triangle-past').innerHTML = formatDetailedItems(weightOfHistory);
            
        //     // Render Key Dynamics - THIS WAS THE MISSING PART
        //     const tensionsHtml = formatSimpleItems(keyDynamics.primary_tensions);
        //     const alignmentHtml = formatSimpleItems(keyDynamics.alignment_opportunities);
        //     const uncertaintiesHtml = formatSimpleItems(keyDynamics.critical_uncertainties);
            
        //     document.getElementById('dynamics-tensions').innerHTML = tensionsHtml;
        //     document.getElementById('dynamics-alignment').innerHTML = alignmentHtml;
        //     document.getElementById('dynamics-uncertainties').innerHTML = uncertaintiesHtml;
            
        //     // Trigger translation if in Lao mode
        //     if (currentLanguage === 'lo') {
        //         setTimeout(() => {
        //             const triangleContent = document.getElementById('futures-triangle-content');
        //             if (triangleContent) {
        //                 console.log('[FUTURES TRIANGLE] Triggering translation for Futures Triangle content');
        //                 translateNewGeneratedContent(triangleContent);
        //             }
        //         }, 100);
        //     }
        // }


// again updated this two function because after converting into laos,when clcik the toggle button again to english means it two was coming empty box,no english generated answer for that only i was updated this function and update the restoreOriginalTexts
        function renderSTEEPV(steepv) {
            const categories = ['social', 'technological', 'economic', 'environmental', 'political', 'values'];
            categories.forEach(cat => {
                const element = document.getElementById(`steepv-${cat}`);
                const data = steepv[cat] || steepv[cat.charAt(0).toUpperCase() + cat.slice(1)] || [];
                
                if (Array.isArray(data) && data.length > 0) {
                    // FIXED: Store original English text before rendering
                    const originalEnglishText = data.map(item => {
                        return typeof item === 'string' ? item : (item.title || item.signal || item);
                    });
                    
                    // Store in element's dataset for later restoration
                    element.dataset.originalEnglish = JSON.stringify(originalEnglishText);
                    
                    // Create a vertical list with each item on its own line
                    const formattedItems = originalEnglishText.map(text => {
                        return `<div style="margin-bottom: 8px; display: block; clear: both;"><span class="translatable">‚Ä¢ ${text}</span></div>`;
                    }).join('');
                    element.innerHTML = formattedItems;
                } else {
                    element.dataset.originalEnglish = JSON.stringify(['No signals identified for this category']);
                    element.innerHTML = '<div style="display: block;"><span class="translatable">No signals identified for this category</span></div>';
                }
            });
            
            // Trigger translation if in Lao mode
            if (currentLanguage === 'lo') {
                setTimeout(() => {
                    const steepvContent = document.getElementById('steepv-content');
                    if (steepvContent) {
                        console.log('[STEEPV] Triggering translation for STEEPV content');
                        translateNewGeneratedContent(steepvContent);
                    }
                }, 100);
            }
        }

        function renderFuturesTriangle(triangle) {
            const pullOfFuture = triangle.pull_of_future || {};
            const pushOfPresent = triangle.push_of_present || {};
            const weightOfHistory = triangle.weight_of_history || {};
            const keyDynamics = triangle.key_dynamics || {};

            function formatDetailedItems(obj, elementId) {
                if (!obj) return '<div><span class="translatable">No data available</span></div>';
                
                const originalData = {};
                let html = '';
                
                for (const [key, items] of Object.entries(obj)) {
                    if (Array.isArray(items) && items.length > 0) {
                        originalData[key] = items;
                        const sectionTitle = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        html += `<div style="margin-bottom: 1rem;">`;
                        html += `<strong class="translatable">${sectionTitle}:</strong><br>`;
                        html += items.map(item => 
                            `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
                        ).join('');
                        html += `</div>`;
                    }
                }
                
                // Store original data
                if (elementId && html) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.dataset.originalEnglish = JSON.stringify(originalData);
                    }
                }
                
                return html || '<div><span class="translatable">No items identified</span></div>';
            }

            function formatSimpleItems(items, elementId) {
                if (!Array.isArray(items) || items.length === 0) {
                    if (elementId) {
                        const element = document.getElementById(elementId);
                        if (element) element.dataset.originalEnglish = JSON.stringify([]);
                    }
                    return '<div><span class="translatable">No items identified</span></div>';
                }
                
                // Store original data
                if (elementId) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.dataset.originalEnglish = JSON.stringify(items);
                    }
                }
                
                return items.map(item => 
                    `<div style="margin: 4px 0;"><span class="translatable">‚Ä¢ ${item}</span></div>`
                ).join('');
            }

            // Render the three forces with data storage
            document.getElementById('triangle-future').innerHTML = formatDetailedItems(pullOfFuture, 'triangle-future');
            document.getElementById('triangle-present').innerHTML = formatDetailedItems(pushOfPresent, 'triangle-present');
            document.getElementById('triangle-past').innerHTML = formatDetailedItems(weightOfHistory, 'triangle-past');
            
            // Render Key Dynamics with data storage
            const tensionsHtml = formatSimpleItems(keyDynamics.primary_tensions, 'dynamics-tensions');
            const alignmentHtml = formatSimpleItems(keyDynamics.alignment_opportunities, 'dynamics-alignment');
            const uncertaintiesHtml = formatSimpleItems(keyDynamics.critical_uncertainties, 'dynamics-uncertainties');
            
            document.getElementById('dynamics-tensions').innerHTML = tensionsHtml;
            document.getElementById('dynamics-alignment').innerHTML = alignmentHtml;
            document.getElementById('dynamics-uncertainties').innerHTML = uncertaintiesHtml;
            
            // Trigger translation if in Lao mode
            if (currentLanguage === 'lo') {
                setTimeout(() => {
                    const triangleContent = document.getElementById('futures-triangle-content');
                    if (triangleContent) {
                        console.log('[FUTURES TRIANGLE] Triggering translation for Futures Triangle content');
                        translateNewGeneratedContent(triangleContent);
                    }
                }, 100);
            }
        }





        // ADD: Helper functions for success/error messages
        function showSuccessMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #d4edda;
                border: 1px solid #c3e6cb;
                color: #155724;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 1000;
                font-weight: 500;
            `;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        function showErrorMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #f8d7da;
                border: 1px solid #f5c6cb;
                color: #721c24;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 1000;
                font-weight: 500;
            `;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        // ADD: Load saved progress on page load
        function loadPhase1Progress() {
            try {
                const saved = localStorage.getItem('phase1_progress');
                if (saved) {
                    const data = JSON.parse(saved);
                    
                    // Restore form fields
                    if (data.project_name) {
                        document.getElementById('project-name').value = data.project_name;
                    }
                    if (data.domain_select) {
                        document.getElementById('domain-select').value = data.domain_select;
                        handleDomainSelection(); // Trigger domain selection logic
                    }
                    if (data.new_domain_name) {
                        document.getElementById('new-domain-name').value = data.new_domain_name;
                    }
                    
                    // Restore generated content
                    if (data.domain_map_generated && data.domain_map_content) {
                        document.getElementById('domain-map-content').innerHTML = data.domain_map_content;
                        document.getElementById('domain-map-content').style.display = 'block';
                    }
                    
                    if (data.interview_analysis_generated && data.interview_analysis_content) {
                        document.getElementById('interview-analysis-content').innerHTML = data.interview_analysis_content;
                        document.getElementById('interview-analysis').style.display = 'block';
                    }
                    
                    savedPhase1Data = data;
                    console.log('Phase 1 progress loaded from localStorage');
                }
            } catch (err) {
                console.error('Error loading saved progress:', err);
            }
        }

        // function renderFuturesTriangle2(triangle2) {
        //     // Render Drivers
        //     const driversContent = document.getElementById('drivers-content');
        //     const drivers = triangle2.drivers || [];
        //     if (drivers.length > 0) {
        //         driversContent.innerHTML = drivers.map(d => `
        //             <div style="margin-bottom: 1rem; padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid #e74c3c;">
        //                 <strong>${d.name}</strong> <span style="color: #666; font-size: 0.875rem;">(${d.impact_level} Impact, ${d.certainty} Certainty)</span><br>
        //                 <span style="color: #555;">${d.description}</span><br>
        //                 <small style="color: #888;"><strong>Category:</strong> ${d.category} | <strong>Trajectory:</strong> ${d.current_trajectory}</small>
        //             </div>
        //         `).join('');
        //     }

        //     // Render Uncertainties
        //     const uncertaintiesContent = document.getElementById('uncertainties-content');
        //     const uncertainties = triangle2.uncertainties || [];
        //     if (uncertainties.length > 0) {
        //         uncertaintiesContent.innerHTML = uncertainties.map(u => `
        //             <div style="margin-bottom: 1rem; padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid #f39c12;">
        //                 <strong>${u.name}</strong><br>
        //                 <span style="color: #555;">${u.description}</span><br>
        //                 <small style="color: #888;"><strong>Possible outcomes:</strong> ${u.possible_outcomes?.join(', ') || 'Various outcomes possible'}</small>
        //             </div>
        //         `).join('');
        //     }

        //     // Render Narratives
        //     const narrativesContent = document.getElementById('narratives-content');
        //     const narratives = triangle2.narratives || [];
        //     if (narratives.length > 0) {
        //         narrativesContent.innerHTML = narratives.map(n => `
        //             <div style="margin-bottom: 1rem; padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid #9b59b6;">
        //                 <strong>${n.name}</strong> <span style="color: #666; font-size: 0.875rem;">(${n.type})</span><br>
        //                 <span style="color: #555;">${n.description}</span><br>
        //                 <small style="color: #888;"><strong>Influence:</strong> ${n.influence_areas?.join(', ') || 'Multiple areas'}</small>
        //             </div>
        //         `).join('');
        //     }
        // }


        // ============================================
        // MODIFY YOUR renderFuturesTriangle2 FUNCTION
        // ============================================
        // Replace the existing renderFuturesTriangle2 with this version that adds translation-friendly classes

        function renderFuturesTriangle2(triangle2) {
            // Render Drivers
            const driversContent = document.getElementById('drivers-content');
            const drivers = triangle2.drivers || [];
            if (drivers.length > 0) {
                driversContent.innerHTML = drivers.map(d => `
                    <div style="margin-bottom: 1rem; padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid #e74c3c;" class="driver-card">
                        <strong class="translatable">${d.name}</strong> 
                        <span style="color: #666; font-size: 0.875rem;">
                            (<span class="translatable">${d.impact_level || 'Unknown'}</span> Impact, 
                            <span class="translatable">${d.certainty || 'Unknown'}</span> Certainty)
                        </span><br>
                        <span style="color: #555;" class="translatable">${d.description || ''}</span><br>
                        <small style="color: #888;">
                            <strong>Category:</strong> <span class="translatable">${d.category || 'Unknown'}</span> | 
                            <strong>Trajectory:</strong> <span class="translatable">${d.current_trajectory || 'Unknown'}</span>
                        </small>
                    </div>
                `).join('');
            }

            // Render Uncertainties
            const uncertaintiesContent = document.getElementById('uncertainties-content');
            const uncertainties = triangle2.uncertainties || [];
            if (uncertainties.length > 0) {
                uncertaintiesContent.innerHTML = uncertainties.map(u => `
                    <div style="margin-bottom: 1rem; padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid #f39c12;" class="uncertainty-card">
                        <strong class="translatable">${u.name}</strong><br>
                        <span style="color: #555;" class="translatable">${u.description || ''}</span><br>
                        <small style="color: #888;">
                            <strong>Possible outcomes:</strong> 
                            <span class="translatable">${(u.possible_outcomes || []).join(', ') || 'Various outcomes possible'}</span>
                        </small>
                    </div>
                `).join('');
            }

            // Render Narratives
            const narrativesContent = document.getElementById('narratives-content');
            const narratives = triangle2.narratives || [];
            if (narratives.length > 0) {
                narrativesContent.innerHTML = narratives.map(n => `
                    <div style="margin-bottom: 1rem; padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid #9b59b6;" class="narrative-card">
                        <strong class="translatable">${n.name}</strong> 
                        <span style="color: #666; font-size: 0.875rem;">
                            (<span class="translatable">${n.type || 'Unknown'}</span>)
                        </span><br>
                        <span style="color: #555;" class="translatable">${n.description || ''}</span><br>
                        <small style="color: #888;">
                            <strong>Influence:</strong> 
                            <span class="translatable">${(n.influence_areas || []).join(', ') || 'Multiple areas'}</span>
                        </small>
                    </div>
                `).join('');
            }
        }


//         function renderBaselineScenario(baseline) {
//             // Clear any existing content first
//             document.getElementById('baseline-text').innerHTML = '';
//             // Update title
//             const titleElement = document.getElementById('baseline-title');
//             if (titleElement) {
//                 titleElement.textContent = baseline.scenario_title || 'Baseline Continuation Scenario';
//             }
            
//             // Update scenario text
//             const textElement = document.getElementById('baseline-text');
//             if (textElement) {
//                 // Convert plain text to HTML with paragraph breaks
//                 const scenarioText = baseline.scenario_text || '';
//                 const paragraphs = scenarioText.split('\n\n').filter(p => p.trim());
                
//                 let html = '';
//                 paragraphs.forEach((paragraph, index) => {
//                     if (paragraph.trim()) {
//                         html += `<p>${paragraph.trim()}</p>`;
//                     }
//                 });
                
//                 // Add key assumptions if available
//                 // Add key assumptions if available
//                 if (baseline.key_assumptions) {
//                     // Ensure key_assumptions is always an array
//                     let assumptions = Array.isArray(baseline.key_assumptions) 
//                         ? baseline.key_assumptions 
//                         : [baseline.key_assumptions];
                    
//                     if (assumptions.length > 0) {
//                         html += '<div style="margin-top: 1.5rem;"><strong>Key Assumptions:</strong><ul>';
//                         assumptions.forEach(assumption => {
//                             html += `<li>${assumption}</li>`;
//                         });
//                         html += '</ul></div>';
//                     }
// }
                
//                 // Add dominant drivers if available
//                 // Add dominant drivers if available
//                 if (baseline.dominant_drivers) {
//                     // Ensure dominant_drivers is always an array
//                     let drivers = Array.isArray(baseline.dominant_drivers) 
//                         ? baseline.dominant_drivers 
//                         : [baseline.dominant_drivers];
                    
//                     if (drivers.length > 0) {
//                         html += '<div style="margin-top: 1rem;"><strong>Dominant Drivers:</strong><ul>';
//                         drivers.forEach(driver => {
//                             html += `<li>${driver}</li>`;
//                         });
//                         html += '</ul></div>';
//                     }
//                 }
                
//                 textElement.innerHTML = html;
//             }
            
//             // Add timeframe info if available
//             if (baseline.timeframe) {
//                 const timeInfo = document.createElement('div');
//                 timeInfo.style.cssText = 'background: #f8f9fa; padding: 0.5rem; border-radius: 4px; margin-bottom: 1rem; color: #666;';
//                 timeInfo.innerHTML = `<strong>Timeframe:</strong> ${baseline.timeframe}`;
//                 textElement.parentNode.insertBefore(timeInfo, textElement);
//             }
//         }






        // FIND YOUR renderBaselineScenario FUNCTION AND REPLACE IT WITH THIS:
        // updated this for baseline scenario come in laos language
        function renderBaselineScenario(baseline) {
            // Clear any existing content first
            document.getElementById('baseline-text').innerHTML = '';
            
            // Update title - ADD class="translatable"
            const titleElement = document.getElementById('baseline-title');
            if (titleElement) {
                const titleText = baseline.scenario_title || 'Baseline Continuation Scenario';
                titleElement.textContent = titleText;
                titleElement.className = 'translatable'; // ADD THIS LINE
            }
            
            // Update scenario text
            const textElement = document.getElementById('baseline-text');
            if (textElement) {
                // Convert plain text to HTML with paragraph breaks
                const scenarioText = baseline.scenario_text || '';
                const paragraphs = scenarioText.split('\n\n').filter(p => p.trim());
                
                let html = '';
                paragraphs.forEach((paragraph, index) => {
                    if (paragraph.trim()) {
                        // ADD class="translatable" to each paragraph
                        html += `<p class="translatable">${paragraph.trim()}</p>`;
                    }
                });
                
                // Add key assumptions if available
                if (baseline.key_assumptions) {
                    let assumptions = Array.isArray(baseline.key_assumptions) 
                        ? baseline.key_assumptions 
                        : [baseline.key_assumptions];
                    
                    if (assumptions.length > 0) {
                        html += '<div style="margin-top: 1.5rem;"><strong>Key Assumptions:</strong><ul>';
                        assumptions.forEach(assumption => {
                            // ADD class="translatable" to each list item
                            html += `<li class="translatable">${assumption}</li>`;
                        });
                        html += '</ul></div>';
                    }
                }
                
                // Add dominant drivers if available
                if (baseline.dominant_drivers) {
                    let drivers = Array.isArray(baseline.dominant_drivers) 
                        ? baseline.dominant_drivers 
                        : [baseline.dominant_drivers];
                    
                    if (drivers.length > 0) {
                        html += '<div style="margin-top: 1rem;"><strong>Dominant Drivers:</strong><ul>';
                        drivers.forEach(driver => {
                            // ADD class="translatable" to each list item
                            html += `<li class="translatable">${driver}</li>`;
                        });
                        html += '</ul></div>';
                    }
                }
                
                textElement.innerHTML = html;
            }
            
            // Add timeframe info if available - ADD class="translatable"
            if (baseline.timeframe) {
                const timeInfo = document.createElement('div');
                timeInfo.style.cssText = 'background: #f8f9fa; padding: 0.5rem; border-radius: 4px; margin-bottom: 1rem; color: #666;';
                timeInfo.innerHTML = `<strong>Timeframe:</strong> <span class="translatable">${baseline.timeframe}</span>`;
                textElement.parentNode.insertBefore(timeInfo, textElement);
            }

            // If user is already in Lao mode, translate immediately
            if (currentLanguage === 'lo') {
                setTimeout(() => {
                    translateNewGeneratedContent(document.getElementById('baseline-scenario-content'));
                }, 100);
            }
        }

        // function renderDriverOutcomes(outcomes) {
        //     const driverSection = document.getElementById('driver-outcomes-results');
        //     if (!driverSection) {
        //         console.error('Element driver-outcomes-results not found');
        //         return;
        //     }
            
        //     let html = '';
            
        //     // EXISTING: Driver Outcomes
        //     const drivers = outcomes.driver_outcomes || [];
        //     if (drivers.length > 0) {
        //         html += '<h4>üîÑ Driver Outcomes</h4>';
        //         drivers.forEach(driver => {
        //             html += `
        //             <div style="margin-bottom: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
        //                 <h5 style="color: #2c3e50; margin-bottom: 1rem;">${driver.driver_name || 'Unnamed Driver'}</h5>
        //                 <div style="margin-bottom: 1rem; padding: 0.5rem; background: #e8f5e5; border-radius: 4px;">
        //                     <strong>Baseline:</strong> ${driver.baseline_trajectory || 'No baseline specified'}
        //                 </div>
        //                 <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
        //                     ${(driver.outcomes || []).map(outcome => `
        //                         <div style="padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid ${getArchetypeColor(outcome.archetype)};">
        //                             <strong>${outcome.archetype || 'Unknown'}</strong><br>
        //                             <span style="color: #555; font-size: 0.9rem;">${outcome.outcome_text || 'No outcome text'}</span>
        //                         </div>
        //                     `).join('')}
        //                 </div>
        //             </div>`;
        //         });
        //     }

        //     // ADD: Uncertainty Outcomes
        //     const uncertainties = outcomes.uncertainty_outcomes || [];
        //     if (uncertainties.length > 0) {
        //         html += '<h4>‚ùì Uncertainty Outcomes</h4>';
        //         uncertainties.forEach(uncertainty => {
        //             html += `
        //             <div style="margin-bottom: 2rem; padding: 1rem; background: #fff8dc; border-radius: 8px;">
        //                 <h5 style="color: #2c3e50; margin-bottom: 1rem;">${uncertainty.uncertainty_name || 'Unnamed Uncertainty'}</h5>
        //                 <div style="margin-bottom: 1rem; padding: 0.5rem; background: #ffeaa7; border-radius: 4px;">
        //                     <strong>Key Variables:</strong> ${(uncertainty.key_variables || []).join(', ') || 'Not specified'}
        //                 </div>
        //                 <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
        //                     ${(uncertainty.outcomes || []).map(outcome => `
        //                         <div style="padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid ${getArchetypeColor(outcome.archetype)};">
        //                             <strong>${outcome.archetype || 'Unknown'}</strong><br>
        //                             <span style="color: #555; font-size: 0.9rem;">${outcome.outcome_text || 'No outcome text'}</span><br>
        //                             <small style="color: #777;"><strong>Resolution:</strong> ${outcome.resolution_direction || 'Not specified'}</small>
        //                         </div>
        //                     `).join('')}
        //                 </div>
        //             </div>`;
        //         });
        //     }

        //     // ADD: Narrative Outcomes
        //     const narratives = outcomes.narrative_outcomes || [];
        //     if (narratives.length > 0) {
        //         html += '<h4>üìñ Narrative Outcomes</h4>';
        //         narratives.forEach(narrative => {
        //             html += `
        //             <div style="margin-bottom: 2rem; padding: 1rem; background: #f0e6ff; border-radius: 8px;">
        //                 <h5 style="color: #2c3e50; margin-bottom: 1rem;">${narrative.narrative_name || 'Unnamed Narrative'}</h5>
        //                 <div style="margin-bottom: 1rem; padding: 0.5rem; background: #d1c4e9; border-radius: 4px;">
        //                     <strong>Type:</strong> ${narrative.narrative_type || 'Not specified'}
        //                 </div>
        //                 <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
        //                     ${(narrative.outcomes || []).map(outcome => `
        //                         <div style="padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid ${getArchetypeColor(outcome.archetype)};">
        //                             <strong>${outcome.archetype || 'Unknown'}</strong><br>
        //                             <span style="color: #555; font-size: 0.9rem;">${outcome.outcome_text || 'No outcome text'}</span><br>
        //                             <small style="color: #777;"><strong>Story Shift:</strong> ${outcome.narrative_shift || 'Not specified'}</small>
        //                         </div>
        //                     `).join('')}
        //                 </div>
        //             </div>`;
        //         });
        //     }

        //     // ADD: Cross-Archetype Insights
        //     const insights = outcomes.cross_archetype_insights || {};
        //     if (Object.keys(insights).length > 0) {
        //         html += `
        //         <div style="margin-top: 2rem; padding: 1.5rem; background: #f5f7fa; border-radius: 8px; border: 2px solid #1976d2;">
        //             <h4>üîç Cross-Archetype Insights</h4>
        //             <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1rem;">
        //                 <div>
        //                     <h5 style="color: #e74c3c;">üîª Collapse Patterns</h5>
        //                     <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        //                         ${(insights.collapse_patterns || []).map(p => `<li>${p}</li>`).join('')}
        //                     </ul>
                            
        //                     <h5 style="color: #f39c12; margin-top: 1rem;">‚öñÔ∏è Equilibrium Patterns</h5>
        //                     <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        //                         ${(insights.equilibrium_patterns || []).map(p => `<li>${p}</li>`).join('')}
        //                     </ul>
        //                 </div>
        //                 <div>
        //                     <h5 style="color: #27ae60;">üöÄ Transformation Patterns</h5>
        //                     <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        //                         ${(insights.transformation_patterns || []).map(p => `<li>${p}</li>`).join('')}
        //                     </ul>
                            
        //                     <h5 style="color: #2c3e50; margin-top: 1rem;">üéØ Leverage Points</h5>
        //                     <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
        //                         ${(insights.leverage_points || []).map(p => `<li>${p}</li>`).join('')}
        //                     </ul>
        //                 </div>
        //             </div>
        //         </div>`;
        //     }

        //     if (html) {
        //         driverSection.innerHTML = html;
        //     } else {
        //         driverSection.innerHTML = '<p>No driver outcomes generated yet.</p>';
        //     }
        // }





//updated this for laos translation for driver outcomes in phase 3

        function renderDriverOutcomes(outcomes) {
            const driverSection = document.getElementById('driver-outcomes-results');
            if (!driverSection) {
                console.error('Element driver-outcomes-results not found');
                return;
            }
            
            let html = '';
            
            // EXISTING: Driver Outcomes
            const drivers = outcomes.driver_outcomes || [];
            if (drivers.length > 0) {
                html += '<h4>üîÑ Driver Outcomes</h4>';
                drivers.forEach(driver => {
                    html += `
                    <div style="margin-bottom: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;" class="translatable">${driver.driver_name || 'Unnamed Driver'}</h5>
                        <div style="margin-bottom: 1rem; padding: 0.5rem; background: #e8f5e5; border-radius: 4px;">
                            <strong>Baseline:</strong> <span class="translatable">${driver.baseline_trajectory || 'No baseline specified'}</span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                            ${(driver.outcomes || []).map(outcome => `
                                <div style="padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid ${getArchetypeColor(outcome.archetype)};">
                                    <strong>${outcome.archetype || 'Unknown'}</strong><br>
                                    <span style="color: #555; font-size: 0.9rem;" class="translatable">${outcome.outcome_text || 'No outcome text'}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>`;
                });
            }

            // ADD: Uncertainty Outcomes
            const uncertainties = outcomes.uncertainty_outcomes || [];
            if (uncertainties.length > 0) {
                html += '<h4>‚ùì Uncertainty Outcomes</h4>';
                uncertainties.forEach(uncertainty => {
                    html += `
                    <div style="margin-bottom: 2rem; padding: 1rem; background: #fff8dc; border-radius: 8px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;" class="translatable">${uncertainty.uncertainty_name || 'Unnamed Uncertainty'}</h5>
                        <div style="margin-bottom: 1rem; padding: 0.5rem; background: #ffeaa7; border-radius: 4px;">
                            <strong>Key Variables:</strong> <span class="translatable">${(uncertainty.key_variables || []).join(', ') || 'Not specified'}</span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                            ${(uncertainty.outcomes || []).map(outcome => `
                                <div style="padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid ${getArchetypeColor(outcome.archetype)};">
                                    <strong>${outcome.archetype || 'Unknown'}</strong><br>
                                    <span style="color: #555; font-size: 0.9rem;" class="translatable">${outcome.outcome_text || 'No outcome text'}</span><br>
                                    <small style="color: #777;"><strong>Resolution:</strong> <span class="translatable">${outcome.resolution_direction || 'Not specified'}</span></small>
                                </div>
                            `).join('')}
                        </div>
                    </div>`;
                });
            }

            // ADD: Narrative Outcomes
            const narratives = outcomes.narrative_outcomes || [];
            if (narratives.length > 0) {
                html += '<h4>üìñ Narrative Outcomes</h4>';
                narratives.forEach(narrative => {
                    html += `
                    <div style="margin-bottom: 2rem; padding: 1rem; background: #f0e6ff; border-radius: 8px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;" class="translatable">${narrative.narrative_name || 'Unnamed Narrative'}</h5>
                        <div style="margin-bottom: 1rem; padding: 0.5rem; background: #d1c4e9; border-radius: 4px;">
                            <strong>Type:</strong> <span class="translatable">${narrative.narrative_type || 'Not specified'}</span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                            ${(narrative.outcomes || []).map(outcome => `
                                <div style="padding: 0.75rem; background: white; border-radius: 4px; border-left: 4px solid ${getArchetypeColor(outcome.archetype)};">
                                    <strong>${outcome.archetype || 'Unknown'}</strong><br>
                                    <span style="color: #555; font-size: 0.9rem;" class="translatable">${outcome.outcome_text || 'No outcome text'}</span><br>
                                    <small style="color: #777;"><strong>Story Shift:</strong> <span class="translatable">${outcome.narrative_shift || 'Not specified'}</span></small>
                                </div>
                            `).join('')}
                        </div>
                    </div>`;
                });
            }

            // ADD: Cross-Archetype Insights
            const insights = outcomes.cross_archetype_insights || {};
            if (Object.keys(insights).length > 0) {
                html += `
                <div style="margin-top: 2rem; padding: 1.5rem; background: #f5f7fa; border-radius: 8px; border: 2px solid #1976d2;">
                    <h4>üîç Cross-Archetype Insights</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1rem;">
                        <div>
                            <h5 style="color: #e74c3c;">üîª Collapse Patterns</h5>
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                                ${(insights.collapse_patterns || []).map(p => `<li class="translatable">${p}</li>`).join('')}
                            </ul>
                            
                            <h5 style="color: #f39c12; margin-top: 1rem;">‚öñÔ∏è Equilibrium Patterns</h5>
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                                ${(insights.equilibrium_patterns || []).map(p => `<li class="translatable">${p}</li>`).join('')}
                            </ul>
                        </div>
                        <div>
                            <h5 style="color: #27ae60;">üöÄ Transformation Patterns</h5>
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                                ${(insights.transformation_patterns || []).map(p => `<li class="translatable">${p}</li>`).join('')}
                            </ul>
                            
                            <h5 style="color: #2c3e50; margin-top: 1rem;">üéØ Leverage Points</h5>
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                                ${(insights.leverage_points || []).map(p => `<li class="translatable">${p}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>`;
            }

            if (html) {
                driverSection.innerHTML = html;
            } else {
                driverSection.innerHTML = '<p>No driver outcomes generated yet.</p>';
            }
        }



        function getArchetypeColor(archetype) {
            switch(archetype) {
                case 'Collapse/Decline': return '#e74c3c';
                case 'New Equilibrium': return '#f39c12'; 
                case 'Transformation': return '#27ae60';
                default: return '#3498db';
            }
        }

// old
        function renderAlternativeScenarios(scenarios) {
            const container = document.getElementById('alternative-scenarios-content');
            if (!container) {
                console.error('Alternative scenarios content container not found');
                return;
            }

            if (!scenarios.scenarios || scenarios.scenarios.length === 0) {
                container.innerHTML = `
                    <div class="alert alert-warning">
                        <h5>No scenarios generated</h5>
                        <p>Please select at least one archetype scenario to generate.</p>
                    </div>
                `;
                return;
            }

            // Group scenarios by archetype for better organization
            const groupedScenarios = scenarios.scenarios.reduce((acc, scenario) => {
                const archetype = scenario.archetype || 'Unknown';
                if (!acc[archetype]) acc[archetype] = [];
                acc[archetype].push(scenario);
                return acc;
            }, {});

            // Define archetype colors and icons
            const archetypeStyles = {
                'Collapse': { color: '#dc3545', bg: '#f8d7da', icon: '‚ö°' },
                'New Equilibrium': { color: '#ffc107', bg: '#fff3cd', icon: '‚öñÔ∏è' },
                'Transformation': { color: '#28a745', bg: '#d4edda', icon: 'üöÄ' }
            };

            let html = `
                <div class="alternative-scenarios-overview">
                    <h4>Generated Alternative Scenarios</h4>
                    <p style="color: #666; margin-bottom: 2rem;">
                        ${scenarios.scenarios.length} scenario${scenarios.scenarios.length !== 1 ? 's' : ''} 
                        across ${Object.keys(groupedScenarios).length} archetype${Object.keys(groupedScenarios).length !== 1 ? 's' : ''}
                    </p>
                </div>
            `;

            // Render each archetype group
            Object.entries(groupedScenarios).forEach(([archetype, archetypeScenarios]) => {
                const style = archetypeStyles[archetype] || { color: '#6c757d', bg: '#f8f9fa', icon: 'üìã' };
                
                html += `
                    <div class="archetype-group" style="margin-bottom: 2rem;">
                        <div class="archetype-header" style="background-color: ${style.bg}; border-left: 4px solid ${style.color}; padding: 12px 16px; border-radius: 6px; margin-bottom: 1rem;">
                            <h5 style="color: ${style.color}; margin: 0; font-weight: 600;">
                                ${style.icon} ${archetype} Scenarios (${archetypeScenarios.length})
                            </h5>
                        </div>
                `;

                // Render scenarios within this archetype
                archetypeScenarios.forEach((scenario, index) => {
                    html += `
                        <div class="card" style="border-left: 3px solid ${style.color}; margin-bottom: 1.5rem;">
                            <div style="margin-bottom: 15px;">
                                <h6 style="color: ${style.color}; font-size: 1.1rem; font-weight: 600; margin-bottom: 8px;">
                                    ${scenario.scenario_title || `${archetype} Scenario ${index + 1}`}
                                </h6>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px;">
                                    <span style="background-color: ${style.color}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 0.75rem;">${archetype}</span>
                                    <span style="background-color: transparent; color: #6c757d; border: 1px solid #dee2e6; padding: 4px 8px; border-radius: 12px; font-size: 0.75rem;">${scenario.timeframe || '2025-2030'}</span>
                                    <span style="background-color: transparent; color: #6c757d; border: 1px solid #dee2e6; padding: 4px 8px; border-radius: 12px; font-size: 0.75rem;">${scenario.probability_assessment || 'Medium'} Likelihood</span>
                                </div>
                            </div>

                            <div class="scenario-content">
                                <div style="line-height: 1.6; margin-bottom: 20px; color: #2c3e50;">
                                    ${formatScenarioText(scenario.scenario_text || 'No scenario text available')}
                                </div>

                                <div class="cards-grid" style="margin-bottom: 20px;">
                                    <div style="background: #f8f9fa; padding: 15px; border-radius: 6px;">
                                        <h6 style="margin-bottom: 10px; color: ${style.color};">Key Factors</h6>
                                        <ul style="list-style: none; padding: 0; margin: 0;">
                                            ${(scenario.key_factors || []).map(factor => 
                                                `<li style="padding: 4px 0; border-bottom: 1px solid #e9ecef; font-size: 0.9rem;">
                                                    <span style="color: #007bff; margin-right: 8px;">‚ñ∂</span>${factor}
                                                </li>`
                                            ).join('')}
                                        </ul>
                                    </div>
                                    <div style="background: #f8f9fa; padding: 15px; border-radius: 6px;">
                                        <h6 style="margin-bottom: 10px; color: ${style.color};">Critical Assumptions</h6>
                                        <ul style="list-style: none; padding: 0; margin: 0;">
                                            ${(scenario.critical_assumptions || []).map(assumption => 
                                                `<li style="padding: 4px 0; border-bottom: 1px solid #e9ecef; font-size: 0.9rem;">
                                                    <span style="margin-right: 8px;">‚ö°</span>${assumption}
                                                </li>`
                                            ).join('')}
                                        </ul>
                                    </div>
                                </div>

                                <div>
                                    <h6 style="margin-bottom: 10px; color: ${style.color};">Early Warning Indicators</h6>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        ${(scenario.key_indicators || []).map(indicator => 
                                            `<span style="padding: 4px 12px; background: #f8f9fa; border: 1px solid ${style.color}; border-radius: 16px; font-size: 0.8rem; color: #495057;">${indicator}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `</div>`; // Close archetype-group
            });

            // Add export button
            html += `
                <div style="text-align: center; padding: 2rem 0; border-top: 2px solid #e9ecef; margin-top: 2rem;">
                    <button class="btn btn-secondary" onclick="exportAlternativeScenarios()" style="margin: 0 8px;">
                        üìÑ Export Scenarios
                    </button>
                </div>
            `;

            container.innerHTML = html;
        }

        // Helper function to format scenario text with proper paragraphs
        function formatScenarioText(text) {
            // Convert to string and handle null/undefined/non-string values
            if (!text || typeof text !== 'string') {
                return '<p>No scenario text available.</p>';
            }
            
            // Convert to string just in case
            text = String(text).trim();
            
            if (!text) {
                return '<p>No scenario text available.</p>';
            }
            
            // Split by double newlines or periods followed by capitals (common paragraph breaks)
            let paragraphs = text.split(/\n\s*\n|\.\s+(?=[A-Z])/);
            
            // If no clear paragraph breaks, try to split by sentence groups
            if (paragraphs.length === 1) {
                const sentences = text.split(/\.\s+/);
                if (sentences.length > 6) {
                    // Group sentences into paragraphs (roughly 2-3 sentences each)
                    paragraphs = [];
                    for (let i = 0; i < sentences.length; i += 3) {
                        paragraphs.push(sentences.slice(i, i + 3).join('. ') + '.');
                    }
                }
            }
            
            // Clean and format paragraphs
            return paragraphs
                .filter(p => p && typeof p === 'string' && p.trim().length > 0)
                .map(paragraph => {
                    const cleaned = String(paragraph).trim().replace(/\n/g, ' ').replace(/\s+/g, ' ');
                    return `<p style="margin-bottom: 12px;">${cleaned}</p>`;
                })
                .join('');
        }

        // Export function for scenarios
        function exportAlternativeScenarios() {
            if (!window.savedAlternativeScenarios) {
                alert('No scenarios to export');
                return;
            }

            const domain = resolveFinalDomain() || 'Unknown Domain';
            const scenarios = window.savedAlternativeScenarios.scenarios || [];
            
            let exportText = `ALTERNATIVE SCENARIOS ANALYSIS\n`;
            exportText += `Domain: ${domain}\n`;
            exportText += `Generated: ${new Date().toLocaleDateString()}\n`;
            exportText += `Total Scenarios: ${scenarios.length}\n\n`;
            exportText += `${'='.repeat(60)}\n\n`;

            scenarios.forEach((scenario, index) => {
                exportText += `SCENARIO ${index + 1}: ${scenario.scenario_title}\n`;
                exportText += `Archetype: ${scenario.archetype}\n`;
                exportText += `Timeframe: ${scenario.timeframe || '2025-2030'}\n`;
                exportText += `Probability: ${scenario.probability_assessment || 'Medium'}\n\n`;
                
                exportText += `NARRATIVE:\n`;
                exportText += `${scenario.scenario_text || 'No narrative available'}\n\n`;
                
                if (scenario.key_factors && scenario.key_factors.length > 0) {
                    exportText += `KEY FACTORS:\n`;
                    scenario.key_factors.forEach(factor => exportText += `‚Ä¢ ${factor}\n`);
                    exportText += `\n`;
                }
                
                if (scenario.critical_assumptions && scenario.critical_assumptions.length > 0) {
                    exportText += `CRITICAL ASSUMPTIONS:\n`;
                    scenario.critical_assumptions.forEach(assumption => exportText += `‚Ä¢ ${assumption}\n`);
                    exportText += `\n`;
                }
                
                if (scenario.key_indicators && scenario.key_indicators.length > 0) {
                    exportText += `EARLY WARNING INDICATORS:\n`;
                    scenario.key_indicators.forEach(indicator => exportText += `‚Ä¢ ${indicator}\n`);
                    exportText += `\n`;
                }
                
                exportText += `${'-'.repeat(60)}\n\n`;
            });

            // Download as text file
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `alternative-scenarios-${domain.replace(/[^a-z0-9]/gi, '_')}-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }




        // Initialize
        // loadPhase1Progress();
        updateProgress();
    </script>
</body>
</html>


